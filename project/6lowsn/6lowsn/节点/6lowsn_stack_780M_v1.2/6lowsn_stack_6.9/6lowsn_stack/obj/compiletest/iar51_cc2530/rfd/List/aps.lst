###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                16/Oct/2013  13:20:07 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\6LoWSN\6lowsn_stack\src\stack\aps.c             #
#    Command line       =  F:\6LoWSN\6lowsn_stack\src\stack\aps.c -D          #
#                          LOWSN_DEBUG -D aExtendedAddress_B7=0x00 -D         #
#                          aExtendedAddress_B6=0x53 -D                        #
#                          aExtendedAddress_B5=0x50 -D                        #
#                          aExtendedAddress_B4=0x40 -D                        #
#                          aExtendedAddress_B3=0x30 -D                        #
#                          aExtendedAddress_B2=0x20 -D                        #
#                          aExtendedAddress_B1=0x10 -D                        #
#                          aExtendedAddress_B0=0x00 -D LOWSN_SENSOR_TYPE=1    #
#                          -lcN F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_ #
#                          cc2530\rfd\List\ -o F:\6LoWSN\6lowsn_stack\obj\com #
#                          piletest\iar51_cc2530\rfd\Obj\ -e --no_cse         #
#                          --no_unroll --no_inline --no_code_motion           #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_cc253 #
#                          0\..\..\..\SRC\STACK\ -I                           #
#                          F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_cc253 #
#                          0\..\..\..\SRC\STACK\TARGET\IAR51\CC2530\ -I       #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 5.3           #
#                          Evaluation version\8051\INC\CLIB\" -Ol             #
#    List file          =  F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_cc253 #
#                          0\rfd\List\aps.lst                                 #
#    Object file        =  F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_cc253 #
#                          0\rfd\Obj\aps.r51                                  #
#                                                                             #
#                                                                             #
###############################################################################

F:\6LoWSN\6lowsn_stack\src\stack\aps.c
      1          
      2          /******************************************************************************************************
      3          *
      4          * 文 件 名：aps.c
      5          *
      6          * 文件描述： 应用层
      7          *
      8          * 创 建 者：Wang Heng
      9          *
     10          * 当前版本：0.50
     11          *
     12          * 修 改 者：
     13          *
     14          * 修改历史：
     15          
     16          
     17          
     18          ********************************************************************************************************/
     19          
     20          #include "compiler.h"
     21          #include "6lowsn_config.h"         //user configurations
     22          #include "6lowsn_common_types.h"   //types common acrosss most files
     23          #include "ieee_lrwpan_defs.h"
     24          #include "console.h"
     25          #include "debug.h"
     26          #include "memalloc.h"
     27          #include "neighbor.h"
     28          #include "ds.h"
     29          #include "hal.h"
     30          #include "halStack.h"
     31          #include "phy.h"
     32          #include "mac.h"
     33          #include "adp.h"
     34          #include "icmpv6.h"
     35          #include "nwk.h"
     36          #include "mp.h"
     37          #include "aps.h"
     38          #include "evboard.h"
     39          #ifdef LOWSN_COORDINATOR
     40          #ifdef LOWSN_SLIP_TO_HOST
     41          #include "slip.h"
     42          #endif
     43          #endif
     44          
     45          
     46          
     47          
     48          #define apsTXIdle() (!aps_pib.flags.bits.TxInProgress)
     49          #define apsTXBusy() (aps_pib.flags.bits.TxInProgress)
     50          #define apsSetTxBusy() aps_pib.flags.bits.TxInProgress = 1
     51          #define apsSetTxIdle() aps_pib.flags.bits.TxInProgress = 0
     52          
     53          
     54          
     55          
     56          APS_PIB aps_pib;
     57          APS_SERVICE a_aps_service;
     58          APS_STATE_ENUM apsState;
     59          APS_EP_ELEM apsEndPoints[LOWSN_MAX_ENDPOINTS];
     60          
     61          //there can only be one TX in progress at a time, so
     62          //a_aps_tx_data contains the arguments for that TX on the APS layer.
     63          APS_TX_DATA a_aps_tx_data;
     64          APS_RX_DATA a_aps_rx_data;
     65          APS_RX_DATA indirect_data;  //used for holding an indirect packet while being reflected.
     66          
     67          static UINT32 aps_utility_timer; 
     68          
     69          #ifdef LOWSN_COORDINATOR
     70          #ifdef LOWSN_SLIP_TO_HOST
     71          // 用于准备APS转发至HOST的头部使用
     72          BYTE aps_header_buf[LOWSN_SLIP_APS_HEADER_LEN]; 
     73          #endif
     74          #endif
     75          
     76          
     77          
     78          void apsFSM(void);
     79          void apsTxData(BOOL copy_payload);
     80          void apsTxIPData(BOOL copy_payload);
     81          
     82          //locals
     83          static APS_RXSTATE_ENUM apsRxState;
     84          static LOWSN_STATUS_ENUM apsTxFSM_status;
     85          
     86          static void apsParseHdr(BYTE *ptr);
     87          static void apsRxFSM(void);
     88          static BOOL apsCheckAck(void);
     89          static BOOL apsCheckCsResponse(void);
     90          static void apsFormatAck(void);
     91          static void apsTxFSM(void);
     92          
     93          #ifdef LOWSN_COORDINATOR
     94          void apsRxBuffInit(void);
     95          BOOL apsRxBuffFull(void);
     96          BOOL apsRxBuffEmpty(void);
     97          APS_RX_DATA *apsGetRxPacket(void);
     98          void apsFreeRxPacket(BOOL freemem);
     99          void apsRxBuffAdd (APS_RX_DATA *ptr);
    100          
    101          #endif
    102          
    103          #ifdef LOWSN_COORDINATOR
    104          #ifdef LOWSN_SLIP_TO_HOST
    105          void apsFormatSlipApsHeader(void);
    106          #endif
    107          #endif
    108          
    109          
    110          //converts MAC TICKs to Microseconds
    111          UINT32 aplMacTicksToUs(UINT32 ticks){
    112          
    113          	return(halMacTicksToUs(ticks));
    114          
    115          }
    116          
    117          //this sleeps, then restarts the stack and the radio
    118          void aplShutdown(void){
    119          	//wait until stack is idle
    120          	while(apsBusy()) apsFSM();
    121          	DISABLE_GLOBAL_INTERRUPT();  //disable interrupts, if halSleep wants to reenable them, let it.
    122          	halShutdown();
    123          	a_aps_service.status = LOWSN_STATUS_SUCCESS;
    124          
    125          }
    126          
    127          void aplWarmstart(void){
    128          	a_aps_service.status = macWarmStartRadio();
    129          }
    130          
    131          
    132          
    133          //this is top level init, does inits for other layers
    134          void apsInit(void){
    135          
    136          	//debug_level = 0;
    137          	//debug_level = DBG_MAX_LEVEL;
    138          	apsState = APS_STATE_IDLE;
    139          	apsRxState = APS_RXSTATE_IDLE;
    140          #ifdef LOWSN_COORDINATOR
    141          	aps_pib.rxCnt = 0;
    142          	aps_pib.rxTail = 0;
    143          	aps_pib.rxHead = 0;
    144          #endif
    145          
    146          	aps_pib.apsTSN = 0;
    147          	aps_pib.apsServiceID = 0;
    148          	aps_pib.apsSeqNum = 0;
    149          	
    150          	aps_pib.flags.val = 0;
    151          	aps_pib.apscAckWaitDuration = MSECS_TO_MACTICKS(LOWSN_APS_ACK_WAIT_DURATION) ; //convert to MAC Ticks
    152          	aps_pib.apsAckWaitMultiplier = 10;  // 目前设置2s内收到ACK，否则认为超时，并未根据跳数设置ACK动态超时时间
    153          	aps_pib.apscMaxFrameRetries = LOWSN_APS_MAX_FRAME_RETRIES ;
    154          
    155          	//initialize the endpoints
    156          	aps_pib.activeEPs = 0;  //only tracks user endpoints.
    157          	phyInit();
    158          	macInit();
    159          	adpInit();
    160          	nwkInit();
    161          	mpInit();
    162          
    163          }
    164          
    165          
    166          void aplFmtSendPublishData (IPADDR dstIPADDR,
    167          							UINT16 dstPort,
    168          							BYTE dstObjID,
    169          							UINT16 srcPort,
    170          							BYTE srcObjID,
    171          							BYTE serviceID, 
    172          							BYTE reqACK, 
    173          							BYTE* pload,
    174          							BYTE  plen)
    175          {
    176          
    177          	while(apsBusy()) apsFSM();
    178          
    179          	a_aps_service.cmd = LOWSN_SVC_APS_GENERIC_TX;
    180          	a_aps_tx_data.flags.val = 0;
    181          	a_aps_tx_data.srcObjID = srcObjID;
    182          	a_aps_tx_data.usrPlen = plen;
    183          	a_aps_tx_data.usrPload = pload;
    184          	a_aps_tx_data.serviceID = serviceID;
    185          	a_aps_tx_data.seqNum= aps_pib.apsSeqNum++;
    186          	a_aps_tx_data.dstObjID = dstObjID;
    187          	
    188          	a_aps_tx_data.dstPort = dstPort;
    189          	a_aps_tx_data.dstIPADDR = dstIPADDR;
    190          	a_aps_tx_data.srcPort = srcPort;
    191          
    192          	a_aps_tx_data.fcf = 0;
    193          	APS_SET_SERVICE_TYPE(a_aps_tx_data.fcf, APS_SERVICE_TYPE_PUBLISH);
    194          
    195          	a_aps_tx_data.flags.bits.loopback = 0;  //暂不考虑loopback地址
    196          
    197          	if (reqACK)  {
    198          		APS_SET_FCF_ACK_FLAG(a_aps_tx_data.fcf);  
    199          	}	
    200          
    201          }
    202          
    203          
    204          void aplFmtSendReportData (IPADDR dstIPADDR,
    205          							UINT16 dstPort,
    206          							BYTE dstObjID,
    207          							UINT16 srcPort,
    208          							BYTE srcObjID,
    209          							BYTE serviceID, 
    210          							BYTE reqACK, 
    211          							BYTE* pload,
    212          							BYTE  plen)
    213          {
    214          
    215          	while(apsBusy()) apsFSM();
    216          
    217          	a_aps_service.cmd = LOWSN_SVC_APS_GENERIC_TX;
    218          	a_aps_tx_data.flags.val = 0;
    219          	a_aps_tx_data.srcObjID = srcObjID;
    220          	a_aps_tx_data.usrPlen = plen;
    221          	a_aps_tx_data.usrPload = pload;
    222          	a_aps_tx_data.serviceID = serviceID;
    223          	a_aps_tx_data.seqNum= aps_pib.apsSeqNum++;
    224          	a_aps_tx_data.dstObjID = dstObjID;
    225          	
    226          	a_aps_tx_data.dstPort = dstPort;
    227          	a_aps_tx_data.dstIPADDR = dstIPADDR;
    228          	a_aps_tx_data.srcPort = srcPort;
    229          
    230          	a_aps_tx_data.fcf = 0;
    231          	APS_SET_SERVICE_TYPE(a_aps_tx_data.fcf, APS_SERVICE_TYPE_REPORT);
    232          
    233          	a_aps_tx_data.flags.bits.loopback = 0;  //暂不考虑loopback地址
    234          
    235          	if (reqACK)  {
    236          		APS_SET_FCF_ACK_FLAG(a_aps_tx_data.fcf);  
    237          	}	
    238          
    239          }
    240          
    241          
    242          
    243          void aplFmtSendCSData(IPADDR dstIPADDR,
    244          				 		UINT16 dstPort,
    245          				 		BYTE dstObjID,
    246          				 		UINT16 srcPort,
    247          				 		BYTE srcObjID,
    248          				 		BYTE  serviceID, 
    249          				 		BYTE  reqACK, 
    250          				 		BYTE* pload,
    251          				 		BYTE  plen, 
    252          				 		BYTE actDirection, 
    253          				 		BYTE actType)
    254          {
    255          
    256          	while(apsBusy()) apsFSM();
    257          
    258          	a_aps_service.cmd = LOWSN_SVC_APS_GENERIC_TX;
    259          	a_aps_tx_data.flags.val = 0;
    260          	a_aps_tx_data.srcObjID = srcObjID;
    261          	a_aps_tx_data.usrPlen = plen;
    262          	a_aps_tx_data.usrPload = pload;
    263          	a_aps_tx_data.serviceID = serviceID;
    264          	a_aps_tx_data.seqNum= aps_pib.apsSeqNum++;
    265          	a_aps_tx_data.dstObjID = dstObjID;
    266          	
    267          	a_aps_tx_data.dstPort = dstPort;
    268          	a_aps_tx_data.dstIPADDR = dstIPADDR;
    269          	a_aps_tx_data.srcPort = srcPort;
    270          
    271          	a_aps_tx_data.fcf = 0;
    272          	APS_SET_SERVICE_TYPE(a_aps_tx_data.fcf, APS_SERVICE_TYPE_CS);
    273          	APS_SET_ACTION_TYPE(a_aps_tx_data.fcf, actType);
    274          
    275          	if ( actDirection == APS_ACTION_RESPONSE)  {
    276          		APS_SET_ACTION_RESPONSE(a_aps_tx_data.fcf);
    277          	}	
    278          
    279          	if (reqACK)  {
    280          		APS_SET_FCF_ACK_FLAG(a_aps_tx_data.fcf);  
    281          	}	
    282          
    283          	if ((actDirection == APS_ACTION_REQUEST) && (actType != APS_ACTION_TYPE_NONE))  {
    284          		a_aps_tx_data.flags.bits.needresponse = 1;
    285          	}	
    286          
    287          	a_aps_tx_data.flags.bits.loopback = 0;  //暂不考虑loopback地址
    288          
    289          
    290          
    291          
    292          
    293          }
    294          
    295          
    296          
    297          void apsFSM(void) 
    298          {
    299            
    300          	nwkFSM();
    301          	//if TxFSM is busy we need to call it
    302          	if (apsTXBusy()) apsTxFSM();
    303          	apsRxFSM(); //check RX
    304          
    305          
    306          apsFSM_start: 
    307          
    308          
    309          	switch (apsState) {
    310          	 case APS_STATE_IDLE:
    311          
    312          		 //ackSendPending check must come before the indirect Pending check!
    313          		 if (aps_pib.flags.bits.ackSendPending) {
    314          			 apsState = APS_STATE_ACK_SEND_START;
    315          			 goto apsFSM_start;
    316          		 }
    317          
    318          		// 查询是否收到管理进程REQUEST请求
    319          		 if (mpIsEventPending()) {
    320          
    321          			switch (mp_pib.eventType)  {
    322          				
    323          
    324          			case MP_EVENT_RECEIVE_REQUEST:
    325          
    326          				// 判断是读/写/执行
    327          				if (APS_GET_ACTION_TYPE(a_aps_rx_data.fcf) == APS_ACTION_TYPE_READ)  {
    328          
    329                           			if (mpReadCheck()) {
    330                             				apsState = APS_STATE_MP_READ_RESPONSE;
    331                             				goto apsFSM_start;
    332                           			}	
    333          					else
    334          					{
    335          						DEBUG_STRING(DBG_INFO,"MP: Invalid READ request. \n");
    336          					}
    337          								
    338          				}	
    339          				else if (APS_GET_ACTION_TYPE(a_aps_rx_data.fcf) == APS_ACTION_TYPE_WRITE)  {
    340          
    341                           			if (mpWriteCheck()) {
    342                             				apsState = APS_STATE_MP_WRITE_RESPONSE;
    343                             				goto apsFSM_start;
    344                           			}	
    345          					else
    346          					{
    347          						DEBUG_STRING(DBG_INFO,"MP: Invalid WRITE request. \n");
    348          					}		
    349          				}	
    350          				else if (APS_GET_ACTION_TYPE(a_aps_rx_data.fcf) == APS_ACTION_TYPE_EXECUTE)  {
    351                           			if (mpExecuteCheck()) {
    352                             				apsState = APS_STATE_MP_EXECUTE_RESPONSE;
    353                             				goto apsFSM_start;
    354                           			}	
    355          					else
    356          					{
    357          						DEBUG_STRING(DBG_INFO,"MP: Invalid EXECUTE request. \n");
    358          					}	
    359          				}		
    360          				else {
    361          					
    362          					DEBUG_STRING(DBG_INFO,"MP: Invalid operation method. \n");
    363          				}	
    364          				
    365          			mpClearEventFlag();
    366          			
    367          			break;
    368          
    369          			case MP_EVENT_SEND_DEVICE_INFO:
    370                           			if (phyTxUnLocked()) {
    371                             				phyGrabTxLock(); 
    372          						mpFmtDeviceInfo(mp_pib.dstAddr);
    373          						mpClearEventFlag();
    374          						
    375          			 			phy_pib.currentTxFlen = 0;  //set frame length to zero, build from scratch
    376          			 			apsTxData(FALSE);           //payload already in TX buffer
    377          						 apsState = APS_STATE_GENERIC_TX_WAIT;
    378                             				goto apsFSM_start;
    379                           			}			
    380          
    381          			break;
    382          
    383          			case MP_EVENT_SEND_TREE_TOPO_INFO:
    384                           			if (phyTxUnLocked()) {
    385                             				phyGrabTxLock(); 
    386          						mpFmtTreeNeighborInfo(mp_pib.dstAddr);
    387          						mpClearEventFlag();
    388          						
    389          			 			phy_pib.currentTxFlen = 0;  //set frame length to zero, build from scratch
    390          			 			apsTxData(FALSE);           //payload already in TX buffer
    391          						apsState = APS_STATE_GENERIC_TX_WAIT;
    392                             				goto apsFSM_start;
    393                           			}			
    394          
    395          			break;
    396          
    397          			default:
    398          				mpClearEventFlag();
    399          
    400          			break;	
    401          
    402          			}
    403          		
    404          		 }
    405          
    406          	 break;
    407          	 
    408          	 case APS_STATE_COMMAND_START:
    409          
    410          		 switch(a_aps_service.cmd) {
    411          	 case LOWSN_SVC_APS_GENERIC_TX:
    412          		 aps_pib.flags.bits.IsUsrBufferFree = 0;
    413          
    414          		 if (a_aps_tx_data.flags.bits.loopback) {
    415          			 apsState = APS_STATE_INJECT_LOOPBACK;  //we are sending a direct packet to ourself!
    416          			 goto apsFSM_start;
    417          		 }
    418          
    419          		 //Indirect vs Direct is handled within the apsTxData() function
    420          		 //at this point ready to begin formating packet.
    421          		 //do not exit this state until we can grab the TX buffer.
    422          		 
    423          		 if (phyTxUnLocked()) {
    424          			 phyGrabTxLock(); //prevents lower stack layers from grabbing TX buffer.
    425          			 phy_pib.currentTxFlen = 0;  //set frame length to zero, build from scratch
    426          
    427          			 apsTxData(TRUE);		 
    428          			 aps_pib.flags.bits.IsUsrBufferFree = 1;
    429          
    430          			 if (a_aps_tx_data.flags.bits.needresponse == 1)  {
    431          				 aps_pib.flags.bits.IsGotCsResponse = 0;
    432          				  aps_pib.flags.bits.WaitCsResponse = 1;
    433          				  apsState = APS_STATE_CS_REQ_TX_WAIT1;
    434          			 }
    435          			 else {
    436          			 	apsState = APS_STATE_GENERIC_TX_WAIT;
    437          			 }	
    438          		 }
    439          		 
    440          		 break;
    441          
    442          	 case LOWSN_SVC_APS_MP_TX:
    443          		 if (phyTxUnLocked()) {
    444          			 phyGrabTxLock(); 
    445          			 switch(a_aps_service.args.mp_tx.commandID)
    446          			 {
    447          	           		case MP_COMMAND_DEVICE_INFORMATION:
    448          			        	mpFmtDeviceInfo(a_aps_service.args.mp_tx.dstIPAddr);
    449          					break;
    450          					
    451          			   	case MP_COMMAND_TREE_NEIGHBOR_INFORMATION:
    452          			   		mpFmtTreeNeighborInfo(a_aps_service.args.mp_tx.dstIPAddr);
    453          					break;
    454          					
    455          			   	default: break;
    456          			 }
    457          
    458          			 phy_pib.currentTxFlen = 0;  //set frame length to zero, build from scratch
    459          			 apsTxData(FALSE);           //payload already in TX buffer
    460          			 apsState = APS_STATE_GENERIC_TX_WAIT;
    461          		 }
    462          
    463          		 break;
    464          
    465          	
    466          	 case LOWSN_SVC_APS_NWK_PASSTHRU:
    467          		 //for NWK calls that have to pass thru the APS layer
    468          		 //this just serves to lock the APS layer while the
    469          		 //the NWK layer is doing its thing
    470          		 if (nwkBusy()) break;  //wait until nwk is idle
    471          		 nwkDoService();
    472          		 apsState = APS_STATE_NWK_PASSTHRU_WAIT;
    473          		 break;
    474          
    475          	 default: break;
    476          		 }//end switch(a_aps_service.cmd)
    477          
    478          		 break;
    479          
    480          	 case APS_STATE_ACK_SEND_START:
    481          		 if (phyTxLocked()) break;
    482          		 //send an ACK
    483          		 //lock the TX buffer
    484          		 phyGrabTxLock();
    485          		 //we are now ready
    486          		 apsFormatAck();
    487          		 phy_pib.currentTxFlen = 0;  //set frame length to zero, build from scratch
    488          		 //因为ACK没有属性负载，所以填充时只需要填充头部，通过isackframe标志位来
    489          		 // 告诉TxData函数ACK帧的不同之处，目前没有编写属性填充的部分，所以该标志位
    490          		 // 并未真正工作.
    491          		 a_aps_tx_data.flags.bits.isackframe = 1;  
    492          		 apsTxData(TRUE);
    493          		 a_aps_tx_data.flags.bits.isackframe = 0;  
    494          		 //data sent, release the RX buffer, will let RX FSM resume
    495          		 aps_pib.flags.bits.ackSendPending = 0;
    496          		 apsState = APS_STATE_GENERIC_TX_WAIT;
    497          
    498          		 break;
    499          
    500          	 case APS_STATE_GENERIC_TX_WAIT:
    501          		 if (!apsTXIdle()) break;
    502          		 //TX is finished, copy status
    503          		 a_aps_service.status = apsTxFSM_status;
    504          		 //release the TX buffer lock before exiting.
    505          		 phyReleaseTxLock();
    506          		 apsState = APS_STATE_IDLE;
    507          		 if (aps_pib.flags.bits.indirectPending) {
    508          			 //have used this state to wait for finishing sending an
    509          			 //ACK back to the source of an indirect transmit. Now
    510          			 //finish resolving the indirect
    511          			 goto apsFSM_start;
    512          		 }
    513          
    514          
    515          		 break;
    516          
    517          
    518          	 case APS_STATE_MP_READ_RESPONSE:
    519          	 	
    520          		if (phyTxLocked())  break;
    521          		phyGrabTxLock();
    522          		
    523          		DEBUG_STRING(DBG_INFO,"Sending MP Read Response\n");
    524          		
    525          		// 解析Read的属性ID，并构造response包
    526                     	mpFmtReadResponse();
    527          
    528          		mpClearEventFlag();
    529          		phy_pib.currentTxFlen = 0;  //必须设置，长度为0才表明不是重传数据
    530          		apsTxData(FALSE);	
    531                     	apsState = APS_STATE_GENERIC_TX_WAIT;
    532          		   
    533                     	break;
    534          
    535          
    536          	 case APS_STATE_MP_WRITE_RESPONSE:
    537          	 	
    538          		if (phyTxLocked())  break;
    539          		phyGrabTxLock();
    540          
    541          		DEBUG_STRING(DBG_INFO,"Sending MP Write Response\n");
    542          		
    543          		// 解析Write的属性ID，并构造response包
    544                     	mpFmtWriteResponse();
    545          
    546          		mpClearEventFlag();
    547          
    548          		phy_pib.currentTxFlen = 0;  //必须设置，长度为0才表明不是重传数据
    549          		apsTxData(FALSE);
    550          	
    551                     	apsState = APS_STATE_GENERIC_TX_WAIT;
    552          		   
    553                     	break;
    554          
    555          
    556          	 case APS_STATE_MP_EXECUTE_RESPONSE:
    557          
    558          		//应该 执行完毕再获取发送缓冲锁    待完善
    559          		if (phyTxLocked())  break;
    560          		phyGrabTxLock();
    561          		
    562          		DEBUG_STRING(DBG_INFO,"Sending MP Execute Response\n");
    563          		
    564          		// 解析要执行的方法并进行执行
    565                     	mpExcuteMethod();
    566          
    567          		mpClearEventFlag();
    568          
    569          		phy_pib.currentTxFlen = 0;  //必须设置，长度为0才表明不是重传数据
    570          		apsTxData(FALSE);
    571          	
    572                       	apsState = APS_STATE_GENERIC_TX_WAIT;
    573          		   
    574                     	break;
    575          
    576          
    577          	 case APS_STATE_CS_REQ_TX_WAIT1:
    578          		 if (!apsTXIdle()) break;
    579          		 //TX is finished, copy status
    580          		
    581          		 phyReleaseTxLock();
    582          
    583          		 if (apsTxFSM_status != LOWSN_STATUS_SUCCESS)  {
    584          		 	a_aps_service.status = apsTxFSM_status;
    585          			aps_pib.flags.bits.WaitCsResponse = 0;
    586          		 	apsState = APS_STATE_IDLE;
    587          			break;
    588          		 }	
    589          
    590                     	 aps_utility_timer = halGetMACTimer();
    591                     	 apsState = APS_STATE_CS_REQ_TX_WAIT2;
    592          	 break;
    593          
    594          	 case APS_STATE_CS_REQ_TX_WAIT2:
    595          		if (aps_pib.flags.bits.IsGotCsResponse) {
    596                        	a_aps_service.status = LOWSN_STATUS_SUCCESS;
    597                       		aps_pib.flags.bits.WaitCsResponse = 0;
    598                       		apsState = APS_STATE_IDLE;	
    599                       }else if ((halMACTimerNowDelta(aps_utility_timer))>APS_CS_RESPONSE_WAIT_TIME){
    600                       //timeout, give it up
    601                       a_aps_service.status = LOWSN_STATUS_APS_CS_RESPONSE_TIMEOUT;
    602                       DEBUG_STRING(DBG_INFO,"APS: Client/Server wait response timeout\n");
    603                       aps_pib.flags.bits.WaitCsResponse = 0;
    604                       apsState = APS_STATE_IDLE;
    605                     }
    606          			 
    607          	    break;
    608          
    609          	 case APS_STATE_NWK_PASSTHRU_WAIT:
    610          		 //for split-phase passthrus
    611          		 if (nwkBusy()) break;
    612          		 a_aps_service.status = a_nwk_service.status;
    613          		 apsState = APS_STATE_IDLE;
    614          		 break;
    615          
    616          	 default:  break;
    617          
    618          
    619          	}//end switch(apsState)
    620          
    621          
    622          }
    623          
    624          
    625          void apsTxData(BOOL copy_payload) {
    626          
    627          	BYTE *src;
    628          
    629          	//if currentTxFlen is zero, we need to build the frame, else, it is
    630          	// a retransmission
    631          	if (phy_pib.currentTxFlen == 0) {
    632          		//assume that the frame is just now being built.
    633          		//use temporary space for building frame
    634          		if (copy_payload){
    635          			//copy user payload into tmpTxBuff space
    636          			//if userPlen is 0, nothing is copied into the payload area
    637          			phy_pib.currentTxFrm = &tmpTxBuff[LOWSN_MAX_FRAME_SIZE];
    638          			//get a pointer to the end of the payload
    639          			src = a_aps_tx_data.usrPload + a_aps_tx_data.usrPlen;
    640          			phy_pib.currentTxFlen = a_aps_tx_data.usrPlen;
    641          			//now copy the user payload to the frame
    642          			while (phy_pib.currentTxFlen) {
    643          				src--;                //decrement to first src location with data
    644          				phy_pib.currentTxFrm--;     //decrement to free location
    645          				phy_pib.currentTxFlen--;    //decrement length
    646          				*(phy_pib.currentTxFrm) = *src;
    647          			}
    648          		} else {
    649          			//assume that TXBuff already has the payload, the ZEP
    650          			//commands build their payload in this space
    651          			//point currentTxFrm to this payload
    652          			phy_pib.currentTxFrm = &tmpTxBuff[LOWSN_MAX_FRAME_SIZE] - a_aps_tx_data.usrPlen;
    653          		}
    654          		//restore length
    655          		phy_pib.currentTxFlen = a_aps_tx_data.usrPlen;
    656          
    657          		// 构造6LOWSN应用层头部
    658          		
    659          		// Source Object Identifier
    660          		--phy_pib.currentTxFrm; 
    661          		*phy_pib.currentTxFrm = a_aps_tx_data.srcObjID;
    662          		phy_pib.currentTxFlen++;
    663          
    664          		// Destination Object Identifier
    665          		--phy_pib.currentTxFrm; 
    666          		*phy_pib.currentTxFrm = a_aps_tx_data.dstObjID;
    667          		phy_pib.currentTxFlen++;
    668          
    669          		// Service Identifier
    670          		--phy_pib.currentTxFrm; 
    671          		*phy_pib.currentTxFrm = a_aps_tx_data.serviceID;
    672          		phy_pib.currentTxFlen++;
    673          
    674          		// Sequence Number
    675          		--phy_pib.currentTxFrm; 
    676          		*phy_pib.currentTxFrm = a_aps_tx_data.seqNum;
    677          		phy_pib.currentTxFlen++;
    678          
    679          		// Frame Control
    680          		--phy_pib.currentTxFrm; 
    681          		*phy_pib.currentTxFrm = a_aps_tx_data.fcf;	
    682          		phy_pib.currentTxFlen++;
    683          
    684          
    685          		// add UDP header
    686          
    687          		// Checksum暂时填0，填充完网络层头部后再计算
    688          		phy_pib.currentTxFrm--;
    689                        *phy_pib.currentTxFrm = 0;
    690                        phy_pib.currentTxFrm--;
    691                        *phy_pib.currentTxFrm = 0;				
    692                         phy_pib.currentTxFlen=phy_pib.currentTxFlen+2;
    693          
    694          		//Length
    695          		// Length is the length in octets of this user datagram including this header and the data. 	
    696          					
    697          		phy_pib.currentTxFrm--;
    698                         *phy_pib.currentTxFrm = (BYTE)((UINT16)(phy_pib.currentTxFlen+6));
    699                         phy_pib.currentTxFrm--;
    700                         *phy_pib.currentTxFrm = (BYTE)(((UINT16)(phy_pib.currentTxFlen+6)) >> 8);			
    701                          phy_pib.currentTxFlen=phy_pib.currentTxFlen+2;
    702          
    703          
    704          		//Destination Port
    705          		phy_pib.currentTxFrm--;
    706                        *phy_pib.currentTxFrm = (BYTE)(a_aps_tx_data.dstPort);
    707                         phy_pib.currentTxFrm--;
    708                        *phy_pib.currentTxFrm = (BYTE)(a_aps_tx_data.dstPort >> 8);				
    709                         phy_pib.currentTxFlen=phy_pib.currentTxFlen+2;
    710          
    711          		//Source Port
    712          		phy_pib.currentTxFrm--;
    713                        *phy_pib.currentTxFrm = (BYTE)(a_aps_tx_data.srcPort);
    714                        phy_pib.currentTxFrm--;
    715                        *phy_pib.currentTxFrm = (BYTE)(a_aps_tx_data.srcPort >> 8);				
    716                        phy_pib.currentTxFlen=phy_pib.currentTxFlen+2;								
    717          					
    718          
    719          		if (a_aps_tx_data.flags.bits.loopback) {
    720          			//Zep commands to ourselves have to go all the way through formatting
    721          			//before we inject them into stack
    722          			//apsInjectTxPacket();
    723          						
    724          		} else {
    725          
    726          			//setup the network layer
    727          			a_nwk_tx_data.Version = LOWSN_IP6_VER;
    728          			a_nwk_tx_data.TrafficClass=0x00;
    729          			a_nwk_tx_data.FlowLabel = 0x00;
    730          			a_nwk_tx_data.PayloadLength = phy_pib.currentTxFlen;
    731          			a_nwk_tx_data.NextHeader = LOWSN_PROTO_UDP;
    732          			a_nwk_tx_data.HopLimit = lowsn_ds6_if.cur_hop_limit;
    733          			a_nwk_tx_data.DstAddress = a_aps_tx_data.dstIPADDR; 
    734          			ds6FindSrcIP(&a_nwk_tx_data.SrcAddress, &a_nwk_tx_data.DstAddress);
    735          			//a_nwk_tx_data.IPStartPtr = phy_pib.currentTxFrm - LOWSN_IPH_LEN;
    736          
    737          	
    738          			//Send via the network layer
    739          			a_nwk_service.cmd = LOWSN_SVC_NWK_GENERIC_TX;
    740          
    741          			
    742          			// at this point, we will attempt a TX
    743          			if (APS_GET_FCF_ACK_FLAG(a_aps_tx_data.fcf)){
    744          							//need an ACK back. set ackPending bit, start timer.
    745          							aps_pib.flags.bits.ackPending = 1;
    746          							aps_pib.tx_start_time = halGetMACTimer();
    747          							//lets compute our Ack Wait duration
    748          							
    749          							//aps_pib.apsAckWaitMultiplier = adpGetHopsToDest(a_nwk_tx_data.dstSADDR);
    750          							// aps_pib.apsAckWaitMultiplier目前固定设定为10，暂不使用动态方式
    751          							
    752          							aps_pib.apsAckWaitMultiplierCntr = aps_pib.apsAckWaitMultiplier;
    753          						}
    754          						else aps_pib.flags.bits.ackPending = 0;
    755          						apsSetTxBusy();
    756          						aps_pib.currentAckRetries = aps_pib.apscMaxFrameRetries; //set retry count
    757          						apsTxFSM_status = LOWSN_STATUS_APS_INPROGRESS;
    758          
    759          						//we need to remember this offset in case of a retry, as we
    760          						//will have to reset the flen to this point
    761          						a_aps_tx_data.aps_flen = phy_pib.currentTxFlen;
    762          						a_aps_tx_data.aps_ptr = phy_pib.currentTxFrm;
    763          					}
    764          
    765          	}
    766          
    767          	if (!a_aps_tx_data.flags.bits.loopback)   {
    768          		nwkDoService();
    769          	}
    770          	
    771          }
    772          
    773          
    774          //handle RX of packets at APS level
    775          static void apsRxFSM(void)
    776          {
    777          	LOWSN_STATUS_ENUM callback_status;
    778          
    779          
    780          apsRxFSM_start:
    781          
    782           switch(apsRxState) {
    783            case APS_RXSTATE_IDLE:
    784          	  break;
    785            case APS_RXSTATE_START:
    786          	  //we have a packet, lets check it out.
    787          	#if 0
    788          	  if (APS_IS_RSV(a_aps_rx_data.aps_fcf)) {
    789          		  //unknown packet type
    790          		  DEBUG_STRING(DBG_INFO,"APS: Received APS RSV packet, discarding.\n");
    791          		  MemFree(a_aps_rx_data.orgpkt.data);
    792          		  apsRxState = APS_RXSTATE_IDLE;
    793          		  break;
    794          	  }
    795          	  if ((APS_GET_FRM_DLVRMODE(a_aps_rx_data.aps_fcf) == APS_FRM_DLVRMODE_BCAST) ||
    796          		  (APS_GET_FRM_DLVRMODE(a_aps_rx_data.aps_fcf) == APS_FRM_DLVRMODE_RSV)){
    797          			  //Delivery mode not handled.
    798          			  DEBUG_STRING(DBG_INFO,"APS: Received APS packet with BCAST or RSV delivery mode, discarding.\n");
    799          			  MemFree(a_aps_rx_data.orgpkt.data);
    800          			  apsRxState = APS_RXSTATE_IDLE;
    801          			  break;
    802          		  }
    803          
    804          	#endif
    805          		  
    806          		  apsParseHdr(a_aps_rx_data.orgpkt.data + a_aps_rx_data.apsOffset);
    807          			
    808          		  if (APS_GET_SERVICE_TYPE(a_aps_rx_data.fcf) == APS_SERVICE_TYPE_ACKFRAME) {
    809          			  if (!aps_pib.flags.bits.ackPending) {
    810          				  //not currently expecting an ACK so discard
    811          				  DEBUG_STRING(DBG_INFO,"APS: Received unexpected ACK, discarding.\n");
    812          			  }else {
    813          				  //lets see if this is our ack.
    814          				  if (apsCheckAck()) {
    815          					  DEBUG_STRING(DBG_INFO,"APS: Received APS ack\n");
    816          					  //this is our ACK, clear the ackPending bit
    817          					  aps_pib.flags.bits.ackPending = 0;
    818          				  } else {
    819          					  DEBUG_STRING(DBG_INFO,"APS: Received ACK, did not match expected.\n");
    820          				  }
    821          
    822          			  }
    823          			  //NWK,MAC resource already free; need to free the MEM resource
    824          			  MemFree(a_aps_rx_data.orgpkt.data);
    825          			  apsRxState = APS_RXSTATE_IDLE;
    826          			  break;
    827          		  }
    828          
    829          
    830          		  // 检查Client/Server模式下的response
    831          		  if ((APS_GET_SERVICE_TYPE(a_aps_rx_data.fcf) == APS_SERVICE_TYPE_CS) &&  
    832          		  	(APS_GET_ACTION_DIRECTION(a_aps_rx_data.fcf) == APS_ACTION_RESPONSE))   {
    833          			
    834          			  if (aps_pib.flags.bits.WaitCsResponse)  {
    835                  			if(apsCheckCsResponse()) {
    836          					DEBUG_STRING(DBG_INFO,"APS: Received Client/Server Response!\n");
    837          					aps_pib.flags.bits.IsGotCsResponse = 1;
    838                  			}
    839          				else {
    840          					DEBUG_STRING(DBG_INFO,"APS: Received Client/Server Respons, not match, discarding!\n");
    841          					MemFree(a_aps_rx_data.orgpkt.data);
    842          			  		apsRxState = APS_RXSTATE_IDLE;
    843          			  		break;
    844          				}				
    845                			  }
    846          
    847          			  else {
    848          
    849          				DEBUG_STRING(DBG_INFO,"APS: Received Client/Server Respons, not request before, discarding!\n");
    850          				MemFree(a_aps_rx_data.orgpkt.data);
    851          			  	apsRxState = APS_RXSTATE_IDLE;
    852          			  	break;
    853          
    854          			  }	
    855          
    856          		  }	
    857          
    858          
    859             		#ifdef LOWSN_COORDINATOR
    860              		#ifdef LOWSN_SLIP_TO_HOST
    861              		if (slip_pib.aps_forward == 1)  {
    862          
    863          			apsFormatSlipApsHeader();
    864                  		apsRxState = APS_RXSTATE_FORWARD_HOST;
    865                  		goto apsRxFSM_start;
    866              		}		
    867              		#endif
    868              		#endif
    869          
    870          
    871          #if 0
    872          		  //check for indirect message
    873          		  if (!a_aps_rx_data.flags.bits.dstEP){
    874          			  //no dest endpoint, must be an indirect message.
    875          #ifdef LOWSN_COORDINATOR
    876          			  //see if we have room to buffer this packet
    877          			  if (apsRxBuffFull()) {
    878          				  //no room, discard this buffer
    879          				  DEBUG_STRING(DBG_INFO,"APS: No room for indirect packet storage, discarding.\n");
    880          				  MemFree(a_aps_rx_data.orgpkt.data);
    881          				  apsRxState = APS_RXSTATE_IDLE;
    882          				  break;
    883          			  }
    884          			  //copy this packet to the APS RX buffer
    885          			  apsRxBuffAdd (&a_aps_rx_data);
    886          			  //first, check to see if an ACK is requested.
    887          			  if (APS_GET_FRM_ACKREQ(a_aps_rx_data.aps_fcf)){
    888          				  //ack request send has to be done in the main FSM
    889          				  aps_pib.flags.bits.ackSendPending = 1;
    890          				  //will have both ackPending and indirectPending set,
    891          				  //the ack pending will be handled first.
    892          			  }
    893          
    894          			  //I am the coordinator, must resolve binding
    895          			  aps_pib.flags.bits.indirectPending = 1;
    896          			  apsRxState = APS_RXSTATE_RESOLVE_INDIRECT;
    897          			  goto apsRxFSM_start;
    898          #else
    899          			  //this is an ERROR. Non-coordinator has an unresolved indirect packet.
    900          			  DEBUG_STRING(DBG_INFO,"APS: Non-Coord Received indirect packet, should not happen, check code.\n");
    901          			  MemFree(a_aps_rx_data.orgpkt.data);
    902          			  apsRxState = APS_RXSTATE_IDLE;
    903          			  break;
    904          #endif
    905          		  }
    906          
    907          #endif
    908          
    909          
    910          		  //如果短端口号为0，则转入管理进程
    911          		  if (a_aps_rx_data.dstPort - LOWSN_BASE_PORT == 0) {
    912          			  //not a user endpoint, handle this
    913          			  DEBUG_STRING(DBG_INFO,"APS: Received MP frame.\n");
    914          
    915          			 if ((APS_GET_SERVICE_TYPE(a_aps_rx_data.fcf) == APS_SERVICE_TYPE_PUBLISH) ||  
    916          		  	(APS_GET_SERVICE_TYPE(a_aps_rx_data.fcf) == APS_SERVICE_TYPE_REPORT))   {
    917          
    918          				callback_status = mpHandleRxReport();
    919          			 }
    920          
    921          			 else if (APS_GET_SERVICE_TYPE(a_aps_rx_data.fcf) == APS_SERVICE_TYPE_CS)  {
    922          
    923          				if (APS_GET_ACTION_DIRECTION(a_aps_rx_data.fcf) == APS_ACTION_REQUEST)  {
    924          
    925          					// 收到请求，置标志位交给主状态机处理
    926          					mpSetEventType(MP_EVENT_RECEIVE_REQUEST);
    927          					mpSetEventFlag();  
    928                					apsRxState = APS_RXSTATE_MP_REQUEST_PENDING;
    929                					break;
    930          				}
    931          				else  {
    932          
    933          					//处理收到的响应
    934          					DEBUG_STRING(DBG_INFO,"MP: Not support handle CS response now.\n");
    935          
    936          				}	
    937          			 }
    938          
    939          			 else  {
    940          			 	DEBUG_STRING(DBG_INFO,"MP: Wrong service type.\n");
    941          			 }	
    942          			 	  
    943          			 // callback_status = zepHandleRxPacket();
    944          			  goto apsRxFSM_freepkt;
    945          		  }
    946          
    947          
    948          		// 其它端口号则转给用户处理
    949          		// 目前尚未支持用户多进程，所以暂未核对端口号是否匹配，以后需增加多进程和
    950          		// 多端口号轮询支持. 
    951          		
    952          		  callback_status = usrRxPacketCallback();
    953          
    954          apsRxFSM_freepkt:
    955          		  //finished, free the space
    956          		  MemFree(a_aps_rx_data.orgpkt.data);
    957          
    958          		  //see if an ACK is requested. Only send back the ack if the callback status
    959          		  //returned as success!
    960          		  if (APS_GET_FCF_ACK_FLAG(a_aps_rx_data.fcf) && callback_status == LOWSN_STATUS_SUCCESS) {
    961          			  //ack request send has to be done in the main FSM
    962          			  aps_pib.flags.bits.ackSendPending = 1;
    963          			  apsRxState = APS_RXSTATE_ACK_SEND_WAIT;
    964          			  break;
    965          		  }
    966          
    967          		  apsRxState = APS_RXSTATE_IDLE;
    968          		  break;
    969          
    970          #if 0
    971          #ifdef LOWSN_COORDINATOR
    972            case APS_RXSTATE_RESOLVE_INDIRECT:
    973          	  if (aps_pib.flags.bits.indirectPending) break;
    974          	  //the main FSM will free up the memory associated with the RX packet
    975          
    976          	  apsRxState = APS_RXSTATE_IDLE;
    977          	  break;
    978          #endif
    979          #endif
    980          
    981            case APS_RXSTATE_ACK_SEND_WAIT:
    982          	if (aps_pib.flags.bits.ackSendPending) break;  //waiting for ACK to be sent
    983          	  //main FSM is finished, can now proceed with new RX
    984          	apsRxState = APS_RXSTATE_IDLE;
    985          	break;
    986          
    987            case APS_RXSTATE_MP_REQUEST_PENDING:
    988          	if (mpIsEventPending())  break;
    989          	MemFree(a_aps_rx_data.orgpkt.data);
    990          	apsRxState = APS_RXSTATE_IDLE;
    991          	break;
    992          
    993            #ifdef LOWSN_COORDINATOR
    994            #ifdef LOWSN_SLIP_TO_HOST
    995            case APS_RXSTATE_FORWARD_HOST:
    996            	if (slipTxLocked())  break;
    997          
    998          	DEBUG_STRING(DBG_INFO,"APS: Forward APS packet to the host.\n");
    999          	slipGrabTxLock();
   1000          	slipSend(&aps_header_buf[0], LOWSN_SLIP_APS_HEADER_LEN, 2);
   1001          	slipSend(a_aps_rx_data.usrPload, a_aps_rx_data.usrPlen, 1);
   1002          	slipReleaseTxLock();
   1003          
   1004          	MemFree(a_aps_rx_data.orgpkt.data);
   1005          	apsRxState = APS_RXSTATE_IDLE;
   1006          
   1007          	break;
   1008            #endif
   1009            #endif
   1010          
   1011            default:
   1012          	  break;
   1013          	}
   1014          
   1015          
   1016          
   1017          }
   1018          
   1019          //see if this matches expected ack.
   1020          static BOOL apsCheckAck(void)
   1021          {
   1022          
   1023          	if ((a_aps_rx_data.srcObjID == a_aps_tx_data.dstObjID) && 
   1024          	     (a_aps_rx_data.dstObjID == a_aps_tx_data.srcObjID) && 
   1025          	     (a_aps_rx_data.serviceID == a_aps_tx_data.serviceID) && 
   1026          	     (a_aps_rx_data.seqNum == a_aps_tx_data.seqNum))  {
   1027          		//this is our ack
   1028          		return TRUE;
   1029          	}
   1030          
   1031          	else  {
   1032          		return FALSE;
   1033          	}	
   1034          }
   1035          
   1036          
   1037          static BOOL apsCheckCsResponse(void)
   1038          {
   1039          
   1040          	if (a_aps_rx_data.serviceID == a_aps_tx_data.serviceID )  {
   1041          		return TRUE;
   1042          	}
   1043          
   1044          	else  {
   1045          		return FALSE;
   1046          	}	
   1047          }
   1048          
   1049          
   1050          #ifdef LOWSN_COORDINATOR
   1051          #ifdef LOWSN_SLIP_TO_HOST
   1052          void apsFormatSlipApsHeader(void)
   1053          {
   1054          	UINT8 i;
   1055          	
   1056          	aps_header_buf[0] = SLIP_APS_FIRST_FLAG;
   1057          	aps_header_buf[1] = SLIP_APS_SECOND_FLAG;
   1058          	aps_header_buf[2] = SLIP_APS_COORD_TO_HOST;
   1059          
   1060          	if (a_aps_rx_data.dstPort - LOWSN_BASE_PORT == 0) {
   1061          		aps_header_buf[3] = SLIP_APS_MP_FRAME;
   1062          	}
   1063          	else {
   1064          		aps_header_buf[3] = SLIP_APS_DATA_FRAME;
   1065          	}	
   1066          
   1067          	aps_header_buf[4] = aplGetRxServiceType();
   1068          
   1069          	for(i=0; i<16; i++) {
   1070                        aps_header_buf[5+i] = a_aps_rx_data.srcAddress.u8[i];
   1071                 }
   1072          
   1073          	aps_header_buf[21] = (BYTE)(a_aps_rx_data.srcPort >> 8);
   1074                 aps_header_buf[22]  = (BYTE)(a_aps_rx_data.srcPort);
   1075          	
   1076          	aps_header_buf[23] = aplGetRxSrcObjectID();
   1077          	
   1078          	aps_header_buf[24] = (BYTE)(a_aps_rx_data.dstPort >> 8);
   1079                 aps_header_buf[25]  = (BYTE)(a_aps_rx_data.dstPort);
   1080          
   1081          	aps_header_buf[26] = aplGetRxDstObjectID();
   1082          	aps_header_buf[27] = aplGetRxServiceID();
   1083          	aps_header_buf[28] = aplGetRxRSSI(); 
   1084          	aps_header_buf[29] = aplGetRxActDirection();
   1085          	aps_header_buf[30] = aplGetRxActType();
   1086          	aps_header_buf[31] = 0;  //目前暂时不使用16位数据长度的高位
   1087          	aps_header_buf[32] = aplGetRxMsgLen();
   1088          
   1089          }
   1090          #endif
   1091          #endif
   1092          
   1093          
   1094          
   1095          
   1096          
   1097          //Callback from NWK Layer
   1098          //Returns TRUE if aps is still busy with last RX packet.
   1099          
   1100          BOOL apsRxBusy(void){
   1101          	return(apsRxState != APS_RXSTATE_IDLE);
   1102          }
   1103          
   1104          void apsRxHandoff(void){
   1105          	
   1106          	a_aps_rx_data.orgpkt.data = a_nwk_rx_data.orgpkt.data;
   1107          	a_aps_rx_data.orgpkt.rssi = a_nwk_rx_data.orgpkt.rssi;
   1108          	a_aps_rx_data.apsOffset = a_nwk_rx_data.pload_offset;
   1109          	a_aps_rx_data.srcAddress = a_nwk_rx_data.SrcAddress;
   1110          	a_aps_rx_data.udp_plen= a_nwk_rx_data.PayloadLength - LOWSN_UDPH_LEN;  //UDP头部本身也带长度域，仍然传递上来，以备将来压缩UDP时使用
   1111          	
   1112          	a_aps_rx_data.srcSADDR = a_nwk_rx_data.srcSADDR;
   1113          	a_aps_rx_data.aps_fcf = *(a_aps_rx_data.orgpkt.data + a_aps_rx_data.apsOffset + LOWSN_UDPH_LEN);//get first byte
   1114          	a_aps_rx_data.flags.val = 0;
   1115          	apsRxState = APS_RXSTATE_START;
   1116          
   1117          }
   1118          
   1119          
   1120          
   1121          //parse the APS header by IP packet
   1122          static void apsParseHdr(BYTE *ptr)
   1123          {
   1124          
   1125          	// get source port
   1126          	//a_aps_rx_data.srcPort = ((UINT16)(*ptr)) << 8 | (UINT16)(*(ptr+1));
   1127          
   1128          	a_aps_rx_data.srcPort = (((UINT16)*ptr) << 8);
   1129          	ptr++;
   1130          	a_aps_rx_data.srcPort += *ptr;
   1131          	ptr++;
   1132          
   1133          	// get destination port
   1134          	a_aps_rx_data.dstPort = (((UINT16)*ptr) << 8);
   1135          	ptr++;
   1136          	a_aps_rx_data.dstPort += *ptr;
   1137          	ptr++;
   1138          	
   1139          	// 应判断UDP端口的可达性，如果不可达，应返回ICMP报文，待以后实现
   1140          
   1141          	// get udp length, only payload
   1142          	a_aps_rx_data.udp_plen = (((UINT16)*ptr) << 8);
   1143          	ptr++;
   1144          	a_aps_rx_data.udp_plen += *ptr;
   1145          	ptr++;
   1146          
   1147          	a_aps_rx_data.udp_plen -= LOWSN_UDPH_LEN;
   1148          
   1149          	
   1150          	ptr = ptr + 2;
   1151          
   1152          	//get the aps fcf byte
   1153          	a_aps_rx_data.fcf = *ptr;
   1154          	ptr++;
   1155          
   1156          	// get the Sequence Number
   1157          	a_aps_rx_data.seqNum= *ptr;
   1158          	ptr++;
   1159          
   1160          	// get the Service Identifier
   1161          	a_aps_rx_data.serviceID= *ptr;
   1162          	ptr++;
   1163          
   1164          	// get the Destination Object Identifier
   1165          	a_aps_rx_data.dstObjID= *ptr;
   1166          	ptr++;
   1167          
   1168          	// get the Source Object Identifier
   1169          	a_aps_rx_data.srcObjID= *ptr;
   1170          	ptr++;
   1171          
   1172          	a_aps_rx_data.attribOffset = LOWSN_UDPH_LEN + 5;
   1173          
   1174          	//get the length of the payload
   1175          	a_aps_rx_data.usrPlen = a_aps_rx_data.udp_plen - 5;
   1176          	//save the pointer to the payload
   1177          	a_aps_rx_data.usrPload = ptr;	
   1178          
   1179          	
   1180          	#if 0
   1181          	if (!((APS_GET_FRM_DLVRMODE(a_aps_rx_data.aps_fcf) == APS_FRM_DLVRMODE_INDIRECT) &&
   1182          		(APS_GET_FRM_INDIRECT_SUBMODE(a_aps_rx_data.aps_fcf)))) {
   1183          			//have a destination EP
   1184          			a_aps_rx_data.flags.bits.dstEP = 1;
   1185          			a_aps_rx_data.dstEP = *ptr;
   1186          			ptr++;
   1187          			len++;
   1188          
   1189          		}
   1190          		//get the cluster ID
   1191          		if (APS_GET_FRM_TYPE(a_aps_rx_data.aps_fcf) == APS_FRM_TYPE_DATA){
   1192          			a_aps_rx_data.cluster = *ptr;
   1193          			ptr++;
   1194          		}
   1195          
   1196          		if ((APS_GET_FRM_TYPE(a_aps_rx_data.aps_fcf) == APS_FRM_TYPE_DATA) ||
   1197          			(APS_GET_FRM_TYPE(a_aps_rx_data.aps_fcf) == APS_FRM_TYPE_ACK)
   1198          			){
   1199          				//get the profile ID
   1200          				a_aps_rx_data.profile = *ptr;
   1201          				ptr++;
   1202          				a_aps_rx_data.profile += (((UINT16)*ptr) << 8);
   1203          				ptr++;
   1204          			}
   1205          
   1206          			len = len +3;
   1207          
   1208          			//get the SRC EP
   1209          			if (!((APS_GET_FRM_DLVRMODE(a_aps_rx_data.aps_fcf) == APS_FRM_DLVRMODE_INDIRECT) &&
   1210          				(!APS_GET_FRM_INDIRECT_SUBMODE(a_aps_rx_data.aps_fcf)))) {
   1211          					//have a SRC EP
   1212          					a_aps_rx_data.flags.bits.srcEP = 1;
   1213          					a_aps_rx_data.srcEP = *ptr;
   1214          					ptr++;
   1215          					len++;
   1216          				}
   1217          
   1218          				//parse AF frame, assume MSG type
   1219          				a_aps_rx_data.afOffset = len;
   1220          
   1221          				//save the af_fcf byte
   1222          				a_aps_rx_data.af_fcf = *ptr;
   1223          				ptr++;
   1224          
   1225          				//get the transaction number
   1226          				a_aps_rx_data.tsn = *ptr;
   1227          				ptr++;
   1228          
   1229          				//get the length of the payload
   1230          				a_aps_rx_data.usrPlen = *ptr;
   1231          				ptr++;
   1232          				//save the pointer to the payload
   1233          				a_aps_rx_data.usrPload = ptr;
   1234          	#endif		
   1235          
   1236          }
   1237          
   1238          //this does not actually format the ACK, just sets
   1239          // the aps_tx fields correctly
   1240          static void apsFormatAck(void)
   1241          {
   1242          
   1243          	a_aps_tx_data.usrPlen = 0;
   1244          	a_aps_tx_data.usrPload = NULL;
   1245          	a_aps_tx_data.fcf = 0;
   1246          	APS_SET_SERVICE_TYPE(a_aps_tx_data.fcf, APS_SERVICE_TYPE_ACKFRAME);
   1247          	a_aps_tx_data.seqNum= a_aps_rx_data.seqNum;
   1248          	a_aps_tx_data.serviceID= a_aps_rx_data.serviceID;
   1249          	a_aps_tx_data.dstObjID= a_aps_rx_data.srcObjID;
   1250          	a_aps_tx_data.srcObjID= a_aps_rx_data.dstObjID;
   1251          
   1252          	a_aps_tx_data.dstPort = a_aps_rx_data.srcPort;
   1253          	a_aps_tx_data.dstIPADDR = a_aps_rx_data.srcAddress;
   1254          	a_aps_tx_data.srcPort = a_aps_rx_data.dstPort;
   1255          
   1256          	a_aps_tx_data.flags.val = 0;
   1257          
   1258          	DEBUG_STRING(DBG_INFO,"APS:Formatted ack\n");
   1259          
   1260          
   1261          }
   1262          
   1263          //handles retries for APS packets that require ACKs
   1264          static void apsTxFSM(void) {
   1265          	if(!apsTXIdle()) {
   1266          		//we are not idle
   1267          		if (nwkIdle()) {
   1268          			//cannot check anything until NWK is idle
   1269          			if (a_nwk_service.status != LOWSN_STATUS_SUCCESS) {
   1270          				//don't bother waiting for ACK, TX did not start correctly
   1271          				aps_pib.flags.bits.ackPending = 0;
   1272          				apsSetTxIdle();  //mark TX as idle
   1273          				apsTxFSM_status = a_nwk_service.status; //return status
   1274          			} else if (!aps_pib.flags.bits.ackPending) {
   1275          				//either no ACK requested or ACK has been received
   1276          				apsSetTxIdle();  //finished successfully, mark as idle
   1277          				apsTxFSM_status = LOWSN_STATUS_SUCCESS;
   1278          			}
   1279          			//check timeout
   1280          			else if (halMACTimerNowDelta(aps_pib.tx_start_time)> aps_pib.apscAckWaitDuration)
   1281          			{
   1282          				//first, check the apsAckWaitMultiplier
   1283          				if(aps_pib.apsAckWaitMultiplierCntr) aps_pib.apsAckWaitMultiplierCntr--;  //this is based on number of hops for the apsAck
   1284          				if (aps_pib.apsAckWaitMultiplierCntr) {
   1285          					//reset the timer.
   1286          					aps_pib.tx_start_time = halGetMACTimer();
   1287          				}else {
   1288          					DEBUG_STRING(1,"APS: TX retry\n");
   1289          					// ACK timeout
   1290          					aps_pib.currentAckRetries--;
   1291          					if (!aps_pib.currentAckRetries) {
   1292          						//retries are zero. We have failed.
   1293          						apsSetTxIdle();
   1294          						DEBUG_STRING(1,"APS TX Retry exceeded\n");
   1295          					} else {
   1296          						//retry...
   1297          						//must reset the len, frm pointers to the beginning of
   1298          						// the formatted aps header before retry
   1299          						phy_pib.currentTxFlen = a_aps_tx_data.aps_flen;
   1300          						phy_pib.currentTxFrm = a_aps_tx_data.aps_ptr;
   1301          						aps_pib.tx_start_time = halGetMACTimer();  //reset the timer
   1302          						aps_pib.apsAckWaitMultiplierCntr = aps_pib.apsAckWaitMultiplier;
   1303          						
   1304          						// 对于重传的包，需要将其UDP校验位置0，
   1305          						// 否则网络层Tx函数计算校验和时会出错.
   1306          						*(phy_pib.currentTxFrm+7) = 0;
   1307          						*(phy_pib.currentTxFrm+6) = 0;
   1308          						
   1309          						apsTxData(TRUE);  //reuse the last packet.
   1310          					}
   1311          				}
   1312          			}
   1313          
   1314          		}
   1315          
   1316          	}
   1317          
   1318          }
   1319          
   1320          
   1321          
   1322          #ifdef LOWSN_COORDINATOR
   1323          
   1324          void apsRxBuffInit(void);
   1325          BOOL apsRxBuffFull(void);
   1326          BOOL apsRxBuffEmpty(void);
   1327          APS_RX_DATA *apsGetRxPacket(void);
   1328          void apsFreeRxPacket(BOOL freemem);
   1329          void apsRxBuffAdd (APS_RX_DATA *ptr);
   1330          
   1331          //copies data into RX buffer
   1332          void apsRxBuffAdd (APS_RX_DATA *ptr){
   1333          	if (aps_pib.rxCnt == APS_RXBUFF_SIZE) {
   1334          		DEBUG_STRING(DBG_ERR,"APS:Trying to add to full buffer in apsRxBuffAdd\n");
   1335          		return;
   1336          	}
   1337          	halUtilMemCopy((BYTE *)&aps_pib.rxBuff[aps_pib.rxHead], (BYTE *)ptr, sizeof(APS_RX_DATA));
   1338          	aps_pib.rxCnt++;
   1339          	aps_pib.rxHead++; //head points to next free location
   1340          	//wrap index
   1341          	if (aps_pib.rxHead == APS_RXBUFF_SIZE) aps_pib.rxHead = 0;
   1342          }
   1343          
   1344          
   1345          
   1346          void apsRxBuffInit(void){
   1347          	aps_pib.rxCnt = 0;
   1348          	aps_pib.rxTail = 0;
   1349          	aps_pib.rxHead = 0;
   1350          }
   1351          
   1352          BOOL apsRxBuffFull(void){
   1353          	return(aps_pib.rxCnt == APS_RXBUFF_SIZE);
   1354          }
   1355          
   1356          
   1357          BOOL apsRxBuffEmpty(void){
   1358          	return(aps_pib.rxCnt == 0);
   1359          }
   1360          
   1361          //this does NOT remove the packet from the buffer
   1362          APS_RX_DATA *apsGetRxPacket(void) {
   1363          	return(&aps_pib.rxBuff[aps_pib.rxTail]);
   1364          }
   1365          
   1366          //frees the first packet in the buffer.
   1367          void apsFreeRxPacket(BOOL freemem) {
   1368          	if (aps_pib.rxCnt == 0) {
   1369          		DEBUG_STRING(DBG_ERR,"APS:Trying to free empty buffer in apsFreeRxPacket\n");
   1370          		return;
   1371          	}
   1372          	if (freemem)MemFree(aps_pib.rxBuff[aps_pib.rxTail].orgpkt.data);
   1373          	aps_pib.rxCnt--;
   1374          	aps_pib.rxTail++;
   1375          	if (aps_pib.rxTail == APS_RXBUFF_SIZE) aps_pib.rxTail = 0;
   1376          
   1377          }
   1378          #endif
   1379          
   1380          
   1381          void aplFormNetworkDirectly() 
   1382          {
   1383           	adpFormNetworkDirectly(); 
   1384          }
   1385          
   1386          
   1387          void aplJoinNetworkDirectly(UINT16 my_saddr, UINT16 parent_saddr, UINT8 *parent_laddr, UINT8 my_depth) 
   1388          {
   1389                      adpJoinNetworkDirectly(my_saddr, parent_saddr, parent_laddr, my_depth);
   1390          }
   1391          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     aplFmtSendCSData                0      0     43
       -> apsFSM                     0      0     38
     aplFmtSendPublishData           0      0     39
       -> apsFSM                     0      0     34
     aplFmtSendReportData            0      0     39
       -> apsFSM                     0      0     34
     aplFormNetworkDirectly          2      0      0
       -> adpFormNetworkDirectly     4      0      0
     aplJoinNetworkDirectly          0      0     14
       -> adpJoinNetworkDirectly     0      0     24
     aplMacTicksToUs                 0      0     12
       -> halMacTicksToUs            0      0     24
     aplShutdown                     2      0      0
       -> apsFSM                     4      0      0
       -> halShutdown                4      0      0
     aplWarmstart                    2      0      0
       -> macWarmStartRadio          4      0      0
     apsCheckAck                     2      0      9
     apsCheckCsResponse              2      0      9
     apsFSM                          0      0     51
       -> nwkFSM                     0      0     32
       -> apsTxFSM                   0      0     32
       -> apsRxFSM                   0      0     32
       -> mpReadCheck                0      0     32
       -> conPrintROMString_func     0      0     32
       -> mpWriteCheck               0      0     32
       -> conPrintROMString_func     0      0     32
       -> mpExecuteCheck             0      0     32
       -> conPrintROMString_func     0      0     32
       -> conPrintROMString_func     0      0     32
       -> mpFmtDeviceInfo            0      0     64
       -> apsTxData                  0      0     32
       -> mpFmtTreeNeighborInfo      0      0     64
       -> apsTxData                  0      0     32
       -> apsTxData                  0      0     32
       -> mpFmtDeviceInfo            0      0     64
       -> mpFmtTreeNeighborInfo      0      0     64
       -> apsTxData                  0      0     32
       -> nwkFSM                     0      0     32
       -> apsFormatAck               0      0     32
       -> apsTxData                  0      0     32
       -> conPrintROMString_func     0      0     32
       -> mpFmtReadResponse          0      0     32
       -> apsTxData                  0      0     32
       -> conPrintROMString_func     0      0     32
       -> mpFmtWriteResponse         0      0     32
       -> apsTxData                  0      0     32
       -> conPrintROMString_func     0      0     32
       -> mpExcuteMethod             0      0     32
       -> apsTxData                  0      0     32
       -> halGetMACTimer             0      0     32
       -> halGetMACTimer             0      0     32
       -> conPrintROMString_func     0      0     32
     apsFormatAck                    2      0     16
       -> conPrintROMString_func     4      0      0
     apsInit                         0      0     12
       -> phyInit                    0      0     24
       -> macInit                    0      0     24
       -> adpInit                    0      0     24
       -> nwkInit                    0      0     24
       -> mpInit                     0      0     24
     apsParseHdr                     2      0      9
     apsRxBusy                       2      0      0
     apsRxFSM                        0      0     25
       -> apsParseHdr                0      0     18
       -> conPrintROMString_func     0      0     18
       -> apsCheckAck                0      0     18
       -> conPrintROMString_func     0      0     18
       -> conPrintROMString_func     0      0     18
       -> MemFree                    0      0     18
       -> apsCheckCsResponse         0      0     18
       -> conPrintROMString_func     0      0     18
       -> conPrintROMString_func     0      0     18
       -> mpHandleRxReport           0      0     18
       -> conPrintROMString_func     0      0     18
       -> MemFree                    0      0     18
       -> conPrintROMString_func     0      0     18
       -> MemFree                    0      0     18
       -> conPrintROMString_func     0      0     18
       -> conPrintROMString_func     0      0     18
       -> usrRxPacketCallback        0      0     18
       -> MemFree                    0      0     18
       -> MemFree                    0      0     18
     apsRxHandoff                    2      0      0
     apsTxData                       1      0     28
       -> ds6FindSrcIP               0      0     24
       -> halGetMACTimer             0      0     24
       -> nwkFSM                     0      0     24
     apsTxFSM                        2      0     28
       -> halGetMACTimer             0      0     24
       -> halGetMACTimer             0      0     24
       -> conPrintROMString_func     0      0     24
       -> conPrintROMString_func     0      0     24
       -> halGetMACTimer             0      0     24
       -> apsTxData                  0      0     24


   Segment part sizes:

     Function/Label                       Bytes
     --------------                       -----
     _A_IEN0                                 1
     aps_pib                                20
     a_aps_service                          20
     apsState                                1
     apsEndPoints                            6
     a_aps_tx_data                          62
     a_aps_rx_data                          82
     indirect_data                          82
     aps_utility_timer                       4
     apsRxState                              1
     apsTxFSM_status                         1
     aplMacTicksToUs                        29
     aplShutdown                            33
     aplWarmstart                           19
     apsInit                               103
     aplFmtSendPublishData                 230
     aplFmtSendReportData                  230
     aplFmtSendCSData                      303
     apsFSM                               1260
     xxxxromstr                             28
     xxxxromstr                             29
     xxxxromstr                             31
     xxxxromstr                             32
     xxxxromstr                             26
     xxxxromstr                             27
     xxxxromstr                             29
     xxxxromstr                             42
     apsTxData                            1000
     apsRxFSM                              538
     xxxxromstr                             43
     xxxxromstr                             23
     xxxxromstr                             44
     xxxxromstr                             39
     xxxxromstr                             61
     xxxxromstr                             70
     xxxxromstr                             25
     xxxxromstr                             41
     xxxxromstr                             25
     apsCheckAck                            65
     apsCheckCsResponse                     29
     apsRxBusy                              23
     apsRxHandoff                          136
     apsParseHdr                           304
     apsFormatAck                          138
     xxxxromstr                             19
     apsTxFSM                              382
     xxxxromstr                             15
     xxxxromstr                             23
     aplFormNetworkDirectly                 14
     aplJoinNetworkDirectly                 35
     __Constant_3070                         4
     ?<Initializer for __Constant_3070>      4
     __Constant_ffffff                       4
     ?<Initializer for __Constant_ffffff>    4
     __Constant_2d691                        4
     ?<Initializer for __Constant_2d691>     4
     __Constant_0                            4
     ?<Initializer for __Constant_0>         4
     ??aplMacTicksToUs?relay                 6
     ??aplShutdown?relay                     6
     ??aplWarmstart?relay                    6
     ??apsInit?relay                         6
     ??aplFmtSendPublishData?relay           6
     ??aplFmtSendReportData?relay            6
     ??aplFmtSendCSData?relay                6
     ??apsFSM?relay                          6
     ??apsTxData?relay                       6
     ??apsRxFSM?relay                        6
     ??apsCheckAck?relay                     6
     ??apsCheckCsResponse?relay              6
     ??apsRxBusy?relay                       6
     ??apsRxHandoff?relay                    6
     ??apsParseHdr?relay                     6
     ??apsFormatAck?relay                    6
     ??apsTxFSM?relay                        6
     ??aplFormNetworkDirectly?relay          6
     ??aplJoinNetworkDirectly?relay          6

 
 4 871 bytes in segment BANKED_CODE
   114 bytes in segment BANK_RELAYS
   672 bytes in segment CODE_C
     1 byte  in segment SFR_AN
    16 bytes in segment XDATA_I
    16 bytes in segment XDATA_ID
   279 bytes in segment XDATA_Z
 
 5 657 bytes of CODE  memory (+ 16 bytes shared)
     0 bytes of DATA  memory (+  1 byte  shared)
   279 bytes of XDATA memory (+ 16 bytes shared)

Errors: none
Warnings: 1
