###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                16/Oct/2013  13:20:09 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\6LoWSN\6lowsn_stack\src\stack\target\iar51\cc25 #
#                          30\halStack.c                                      #
#    Command line       =  F:\6LoWSN\6lowsn_stack\src\stack\target\iar51\cc25 #
#                          30\halStack.c -D LOWSN_DEBUG -D                    #
#                          aExtendedAddress_B7=0x00 -D                        #
#                          aExtendedAddress_B6=0x53 -D                        #
#                          aExtendedAddress_B5=0x50 -D                        #
#                          aExtendedAddress_B4=0x40 -D                        #
#                          aExtendedAddress_B3=0x30 -D                        #
#                          aExtendedAddress_B2=0x20 -D                        #
#                          aExtendedAddress_B1=0x10 -D                        #
#                          aExtendedAddress_B0=0x00 -D LOWSN_SENSOR_TYPE=1    #
#                          -lcN F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_ #
#                          cc2530\rfd\List\ -o F:\6LoWSN\6lowsn_stack\obj\com #
#                          piletest\iar51_cc2530\rfd\Obj\ -e --no_cse         #
#                          --no_unroll --no_inline --no_code_motion           #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_cc253 #
#                          0\..\..\..\SRC\STACK\ -I                           #
#                          F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_cc253 #
#                          0\..\..\..\SRC\STACK\TARGET\IAR51\CC2530\ -I       #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 5.3           #
#                          Evaluation version\8051\INC\CLIB\" -Ol             #
#    List file          =  F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_cc253 #
#                          0\rfd\List\halStack.lst                            #
#    Object file        =  F:\6LoWSN\6lowsn_stack\obj\compiletest\iar51_cc253 #
#                          0\rfd\Obj\halStack.r51                             #
#                                                                             #
#                                                                             #
###############################################################################

F:\6LoWSN\6lowsn_stack\src\stack\target\iar51\cc2530\halStack.c
      1          
      2          /******************************************************************************************************
      3          *
      4          * 文 件 名：halStack.c
      5          *
      6          * 文件描述：射频收发与定时器等函数及中断函数
      7          *
      8          * 创 建 者：Wang Heng
      9          *
     10          * 当前版本： 0.50
     11          *
     12          * 修 改 者：
     13          *
     14          * 修改历史：
     15          
     16            2013-05-25  22:38  by Wang Heng
     17             以WIA-PA CC2530为蓝本，移植到CC2530，上层功能运行成功，
     18             RF收发和MAC Timer功能进行了大量改进. 
     19          
     20          
     21          ********************************************************************************************************/
     22          
     23          
     24          #include "compiler.h"
     25          #include "hal.h"
     26          #include "halStack.h"
     27          #include "console.h"
     28          #include "debug.h"
     29          #include "ieee_lrwpan_defs.h"
     30          #include "memalloc.h"
     31          #include "phy.h"
     32          #include "mac.h"
     33          
     34          
     35          
     36          /****************************************************************************************************
     37          * global variables
     38          */
     39          RADIO_FLAGS local_radio_flags;
     40          
     41          BYTE volatile long_address[8];
     42          
     43          #ifdef  LOWSN_ASYNC_INTIO
     44          BYTE serio_rxBuff[LOWSN_ASYNC_RX_BUFSIZE];
     45          BYTE serio_rxHead, serio_rxTail;
     46          #endif
     47          
     48          UINT8 ReceiveFlag;
     49          
     50          
     51          /****************************************************************************************************
     52          * contstant
     53          */
     54          #define T2CMPVAL  64
     55          
     56          /****************************************************************************************************
     57          * function
     58          */
     59          /*********************************************************************************************
     60          @function:
     61          
     62          halInit contains both processor specific initialization
     63          **********************************************************************************************/
     64          void halInit(void)
     65          {
     66            local_radio_flags.val = 0;
     67            SET_MAIN_CLOCK_SOURCE();
     68            halInitUart();
     69            halSetBaud(LOWSN_DEFAULT_BAUDRATE);
     70            halInitMACTimer();
     71          }
     72          
     73          
     74          void halInitUart(void) {
     75          
     76            IO_PER_LOC_UART0_AT_PORT0_PIN2345();
     77            UTX0IF = 1;
     78          
     79          #ifdef LOWSN_ASYNC_INTIO
     80            serio_rxHead = 0;
     81            serio_rxTail = 0;
     82            INT_ENABLE_URX0(INT_ON);
     83          #endif
     84          }
     85          
     86          
     87          void halPutch(char c)
     88          {
     89            while (!UTX0IF);
     90            UTX0IF = 0;
     91            U0DBUF = c;
     92          }
     93          
     94          void halRawPut(char c)
     95          {
     96            while (!UTX0IF);
     97            UTX0IF = 0;
     98            U0DBUF = c;
     99          }
    100          
    101          
    102          #ifdef  LOWSN_ASYNC_INTIO
    103          /*********************************************************************************************
    104          @function:
    105          
    106          get a character from serial port, uses interrupt driven IO
    107          **********************************************************************************************/
    108          char halGetch(void){
    109            char x;
    110            do {
    111              x = serio_rxHead;  //use tmp because of volt decl
    112            }  while(serio_rxTail == x);
    113            serio_rxTail++;
    114            if (serio_rxTail == LOWSN_ASYNC_RX_BUFSIZE) serio_rxTail = 0;
    115            return (serio_rxBuff[serio_rxTail]);
    116          }
    117          
    118          
    119          /*********************************************************************************************
    120          @function:
    121          
    122          **********************************************************************************************/
    123          BOOL halGetchRdy(void){
    124            char x;
    125            x = serio_rxHead;
    126            return(serio_rxTail != x);
    127          }
    128          
    129          #else
    130          
    131          char halGetch (void ){
    132            char c;
    133          
    134            while (!URX0IF);
    135            c = U0DBUF;
    136            URX0IF = FALSE;
    137          
    138            return c;
    139          }
    140          
    141          /*********************************************************************************************
    142          @function:
    143          
    144          **********************************************************************************************/
    145          BOOL halGetchRdy(void){
    146          
    147            if (URX0IF) return (1);
    148            else return(0);
    149          
    150          }
    151          
    152          #endif
    153          
    154          /*********************************************************************************************
    155          @function:
    156          
    157          **********************************************************************************************/
    158          void halUtilMemCopy(BYTE *dst, BYTE *src, BYTE len) {
    159            while (len) {
    160              *dst = *src;
    161              dst++;src++;
    162              len--;
    163            }
    164          }
    165          
    166          
    167          
    168          
    169          // assuming 16us period, have 1/16us = 62500 tics per seocnd
    170          #define T2OVFNUM (62500/SLOWTICKS_PER_SECOND)
    171          
    172          /*********************************************************************************************
    173          @function:
    174          
    175          
    176          **********************************************************************************************/
    177          void halInitMACTimer(void)
    178          {
    179                 //使T2空闲，及确定其它寄存器的状态
    180          	T2CTRL = 0x00;//T2控制寄存器
    181          	T2IRQM = 0x00;//T2中断屏蔽
    182          
    183          	//选  择T2M为定时周期 
    184          	MAC_MCU_T2_ACCESS_PERIOD_VALUE();
    185          
    186                 //定时周期320 * 31.25ns = 10000 ns = 10us
    187          	//T2M0 = 0x40;
    188          	//T2M1 = 0x01;
    189          
    190          	// 总是需先读或写T2M0，然后再T2M1
    191          	T2M0 = 0x00;  // (0x0200) / 32 = 16 u-seconds
    192          	T2M1 = 0x02;  // setting for 16 u-second periods
    193          
    194          
    195          	#ifdef LOWSN_ENABLE_SLOW_TIMER
    196          	
    197          	// 屏蔽TIMER2_PERIM中断
    198          	T2IRQM &= ~TIMER2_PERM;
    199          	
    200                 //选择T2MOVF溢出中断
    201          	MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
    202          
    203          	T2MOVF0 = (BYTE) (T2OVFNUM);
    204          	T2MOVF1 = (BYTE) (T2OVFNUM>>8);
    205          	T2MOVF2 = (BYTE) (T2OVFNUM>>16);
    206          
    207          	//T2MOVF 比较中断使能
    208          	T2IRQM |= TIMER2_OVF_COMPARE1M;
    209          	   
    210          	 #endif
    211          
    212                 //设置LATCH_MODE
    213                // T2CTRL |= LATCH_MODE;
    214          	T2CTRL &= ~LATCH_MODE;
    215          
    216          	//启动T2，开始计时
    217          	MAC_RADIO_TIMER_WAKE_UP();
    218          
    219          	#ifdef LOWSN_ENABLE_SLOW_TIMER
    220                 //清除中断标志位
    221          	INT_SETFLAG_T2(INT_CLR);
    222          
    223                 //打开T2中断使能
    224                 INT_ENABLE_T2(INT_ON);
    225          
    226          	 INT_GLOBAL_ENABLE(INT_ON);
    227          
    228          	#endif
    229          
    230          }
    231          
    232          
    233          /*********************************************************************************************
    234          @function:
    235          
    236          **********************************************************************************************/
    237          UINT32 halGetMACTimer(void)
    238          {
    239            //UINT32 overflowCount;
    240            UINT32 t;
    241            BOOL gie_status;
    242          
    243            SAVE_AND_DISABLE_GLOBAL_INTERRUPT(gie_status);
    244          
    245           /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    246            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    247          
    248            //读T2M0锁定定时器t2tim和溢出计数器t2ovf的值，然后读数值
    249          
    250            t = 0x0FF & T2MOVF0;
    251            t += (((UINT16)T2MOVF1)<<8);
    252            t += (((UINT32)T2MOVF2)<<16);
    253          
    254           // ((UINT8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
    255           // ((UINT8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
    256            //((UINT8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
    257           // ((UINT8 *)&overflowCount)[UINT32_NDX3] = 0;
    258          
    259            RESTORE_GLOBAL_INTERRUPT(gie_status);
    260            //return (overflowCount);
    261            
    262            return (t);
    263          
    264            
    265          }
    266          
    267          
    268          
    269          /**************************************************************************************************
    270           * @fn          macMcuOverflowCapture
    271           *
    272           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    273           *              captures the overflow counter when the regular hardware timer is captured.
    274           *
    275           * @param       none
    276           *
    277           * @return      last capture of overflow count
    278           **************************************************************************************************
    279           */
    280          UINT32 macMcuOverflowCapture(void)
    281          {
    282            UINT32  overflowCapture;
    283            halIntState_t  s;
    284          
    285            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    286            HAL_ENTER_CRITICAL_SECTION(s);
    287            MAC_MCU_T2_ACCESS_OVF_CAPTURE_VALUE();
    288            ((UINT8 *)&overflowCapture)[UINT32_NDX0] = T2MOVF0;
    289            ((UINT8 *)&overflowCapture)[UINT32_NDX1] = T2MOVF1;
    290            ((UINT8 *)&overflowCapture)[UINT32_NDX2] = T2MOVF2;
    291            ((UINT8 *)&overflowCapture)[UINT32_NDX3] = 0;
    292            HAL_EXIT_CRITICAL_SECTION(s);
    293          
    294            return (overflowCapture);
    295          }
    296          
    297          /**************************************************************************************************
    298           * @fn          halOverflowSetCount
    299           *
    300           * @brief       Sets the value of the hardware overflow counter.
    301           *
    302           * @param       count - new overflow count value
    303           *
    304           * @return      none
    305           ***************************************************************************************************/
    306           void halOverflowSetCount(UINT32 count)//ts
    307          {
    308          	  BOOL gie_status;
    309          
    310          	  SAVE_AND_DISABLE_GLOBAL_INTERRUPT(gie_status);
    311          	
    312           	 MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    313          
    314          	  /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    315          	  /* T2OF2 must be written last */
    316          
    317          
    318          	   T2MOVF0 = (UINT8) count;
    319          	   T2MOVF1 = (UINT8)(count>>8);
    320          	   T2MOVF2 = (UINT8)(count>>16);
    321          	   RESTORE_GLOBAL_INTERRUPT(gie_status);
    322          }
    323          
    324          
    325          
    326          /*********************************************************************************************
    327          @function:
    328          
    329          **********************************************************************************************/
    330          #ifdef LOWSN_COMPILER_NO_RECURSION
    331          UINT32 halISRGetMACTimer(void){
    332            UINT32 t;
    333            BOOL gie_status;
    334          
    335            SAVE_AND_DISABLE_GLOBAL_INTERRUPT(gie_status);
    336            t = 0x0FF & T2MOVF0;
    337            t += (((UINT16)T2MOVF1)<<8);
    338            t += (((UINT32) T2MOVF2 & 0x0F)<<16);
    339            RESTORE_GLOBAL_INTERRUPT(gie_status);
    340            return (t);
    341          }
    342          
    343          #endif
    344          
    345          
    346          
    347          /*********************************************************************************************
    348          @function:
    349          
    350          only works as long as SYMBOLS_PER_MAC_TICK is not less than 1
    351          **********************************************************************************************/
    352          UINT32 halMacTicksToUs(UINT32 ticks){
    353          
    354            UINT32 rval;
    355          
    356            rval =  (ticks/SYMBOLS_PER_MAC_TICK())* (1000000/LOWSN_SYMBOLS_PER_SECOND);
    357            return(rval);
    358          }
    359          
    360          
    361          /*********************************************************************************************
    362          @function:
    363          
    364          assumes that Timer2 has been initialized and is running
    365          **********************************************************************************************/
    366          UINT8 halGetRandomByte(void) {
    367            return(T2MOVF0);
    368          }
    369          
    370          
    371          
    372          
    373          /*********************************************************************************************
    374          @function:
    375          
    376          set the radio frequency
    377          **********************************************************************************************/
    378          LOWSN_STATUS_ENUM halSetRadioIEEEFrequency(PHY_FREQ_ENUM frequency, BYTE channel)
    379          {
    380            //UINT16 afreq;
    381            BOOL gie_status;
    382          
    383            if (frequency != PHY_FREQ_2405M) return(LOWSN_STATUS_PHY_FAILED);
    384            if ((channel < 11) || (channel > 28)) return(LOWSN_STATUS_PHY_FAILED);  //CC2530 supports channel 27 and 28.
    385          
    386            // enter critical code.
    387          
    388            SAVE_AND_DISABLE_GLOBAL_INTERRUPT(gie_status);
    389          
    390            // close RX state. Make sure it is not on the tranmiting state.
    391          
    392            // Rx off
    393            MAC_RADIO_RXTX_OFF();
    394            //just in case a receive was about to start, flush the receive FIFO
    395          
    396            MAC_RADIO_FLUSH_RX_FIFO();
    397            //clear any receive interrupt that happened to squeak through
    398            MAC_RADIO_CLEAR_RX_THRESHOLD_INTERRUPT_FLAG();
    399          
    400            // set Frequency register
    401            // FSCTRLH has no sense, because it always be 01.
    402            //MAC_RADIO_SET_CHANNEL(channel);
    403            FREQCTRL = FREQ_2405MHZ + 5 * ((channel) - 11);
    404            //afreq = 357 + 5*(channel - 11);
    405            //FSCTRLL = (BYTE) afreq;
    406            //FSCTRLH = ((FSCTRLH & ~0x03) | (BYTE)((afreq >> 8) & 0x03));
    407          
    408            // RX on
    409            MAC_RADIO_RX_ON();
    410          
    411            RESTORE_GLOBAL_INTERRUPT(gie_status);
    412          
    413          
    414            return(LOWSN_STATUS_SUCCESS);
    415          }
    416          
    417          LOWSN_STATUS_ENUM halSetChannel(BYTE channel)
    418          {
    419           	return(halSetRadioIEEEFrequency(PHY_FREQ_2405M, channel));
    420          }
    421          
    422          
    423          #if 0
    424          /*********************************************************************************************
    425          @function:
    426          
    427          this assumes 2.4GHz frequency
    428          **********************************************************************************************/
    429          #if defined(IAR8051)
    430          //this uses the IEEE address stored in program memory.
    431          //ensure that the flash programmer is configured to retain
    432          //the IEEE address
    433          __near_func void halGetProcessorIEEEAddress(BYTE *buf)
    434          {
    435          
    436            unsigned char memCtr;
    437            unsigned char bank;
    438          
    439            memCtr = MEMCTR;
    440            bank = FMAP;
    441          
    442           //switch to bank 7
    443           MEMCTR |=0x0F;
    444           FMAP |= 0x07;
    445            //note that the flash programmer stores these in BIG ENDIAN order for some reason!!!
    446            buf[0] = aExtendedAddress_B0;
    447            buf[1] = aExtendedAddress_B1;
    448            buf[2] = aExtendedAddress_B2;
    449            buf[3] = aExtendedAddress_B3;
    450            buf[4] = aExtendedAddress_B4;
    451            buf[5] = aExtendedAddress_B5;
    452            buf[6] = aExtendedAddress_B6;
    453            buf[7] = aExtendedAddress_B7;
    454          /*
    455            buf[7] = *(ROMCHAR *)(IEEE_ADDRESS_ARRAY+0);
    456            buf[6] = *(ROMCHAR *)(IEEE_ADDRESS_ARRAY+1);
    457            buf[5] = *(ROMCHAR *)(IEEE_ADDRESS_ARRAY+2);
    458            buf[4] = *(ROMCHAR *)(IEEE_ADDRESS_ARRAY+3);
    459            buf[3] = *(ROMCHAR *)(IEEE_ADDRESS_ARRAY+4);
    460            buf[2] = *(ROMCHAR *)(IEEE_ADDRESS_ARRAY+5);
    461            buf[1] = *(ROMCHAR *)(IEEE_ADDRESS_ARRAY+6);
    462            buf[0] = *(ROMCHAR *)(IEEE_ADDRESS_ARRAY+7);
    463          */
    464          
    465            //resore old bank settings
    466            MEMCTR = memCtr;
    467            FMAP = bank;
    468          
    469          
    470          }
    471          
    472          #endif
    473          
    474          #endif
    475          
    476          
    477          
    478          
    479          // 为了调试方便，使用自己设定的EUI64地址
    480          // 务必注意: CC2430存储EUI64地址是采用小端格式的, 而协议栈在设定
    481          // 时都是按照大端格式( 即阅读顺序处理的)
    482          // 这个以后需要专门理顺，否则可能与其他协议栈会有互通问题.
    483          
    484          
    485          
    486          __near_func void halGetProcessorIEEEAddress(BYTE *buf) 
    487          {
    488          	buf[0] = aExtendedAddress_B0;
    489          	buf[1] = aExtendedAddress_B1;
    490          	buf[2] = aExtendedAddress_B2;
    491          	buf[3] = aExtendedAddress_B3;
    492          	buf[4] = aExtendedAddress_B4;
    493          	buf[5] = aExtendedAddress_B5;
    494          	buf[6] = aExtendedAddress_B6;
    495          	buf[7] = aExtendedAddress_B7;
    496          
    497          }
    498          
    499          
    500          // 暂时为了MAC层长地址按反阅读顺序发送而进行设定，以后需要统一处理长地址
    501          __near_func void halGetProcessorIEEEAddress_MAC(BYTE *buf) 
    502          {
    503          
    504          	buf[0] = aExtendedAddress_B7;
    505          	buf[1] = aExtendedAddress_B6;
    506          	buf[2] = aExtendedAddress_B5;
    507          	buf[3] = aExtendedAddress_B4;
    508          	buf[4] = aExtendedAddress_B3;
    509          	buf[5] = aExtendedAddress_B2;
    510          	buf[6] = aExtendedAddress_B1;
    511          	buf[7] = aExtendedAddress_B0;
    512          }
    513          
    514          
    515          
    516          // 在编译器参数中配置的aExtendedAddress_B0-B7是按大端格式存储的(自己设定的)
    517          // 这里存储到芯片中时需要反转
    518          // 芯片中存储的是小端格式
    519          
    520          void halSetRadioIEEEAddress(void)
    521          {
    522            BYTE buf[8];
    523            halGetProcessorIEEEAddress_MAC(buf);
    524          	  EXT_ADDR0 = buf[0];
    525          	  EXT_ADDR1 = buf[1];
    526          	  EXT_ADDR2 = buf[2];
    527          	  EXT_ADDR3 = buf[3];
    528          	  EXT_ADDR4 = buf[4];
    529          	  EXT_ADDR5 = buf[5];
    530          	  EXT_ADDR6 = buf[6];
    531          	  EXT_ADDR7 = buf[7];
    532          }
    533          
    534          /*********************************************************************************************
    535           * @fn          halSetRadioPANID
    536           *
    537           * @brief       Set the pan ID on the radio.
    538           *
    539           * @param       panID - 16 bit PAN identifier
    540           *
    541           * @return      none
    542          
    543          **********************************************************************************************/
    544          void halSetRadioPANID(UINT16 panid)
    545          {
    546              MAC_RADIO_SET_PAN_ID(panid);
    547          }
    548          
    549          /*********************************************************************************************
    550           * @fn          halSetRadioShortAddr
    551           *
    552           * @brief       Set the short addrss on the radio.
    553           *
    554           * @param       shortAddr - 16 bit short address
    555           *
    556           * @return      none
    557          
    558          **********************************************************************************************/
    559          void halSetRadioShortAddr(SADDR saddr)
    560          {
    561             MAC_RADIO_SET_SHORT_ADDR(saddr);
    562          }
    563          
    564          
    565          /*********************************************************************************************
    566          @function:
    567          
    568          **********************************************************************************************/
    569          LOWSN_STATUS_ENUM halInitRadio(PHY_FREQ_ENUM frequency, BYTE channel, RADIO_FLAGS radio_flags)
    570          {
    571            LOWSN_STATUS_ENUM status;
    572          
    573          
    574            // Setting the frequency
    575            status = halSetRadioIEEEFrequency(frequency, channel);
    576            if (status != LOWSN_STATUS_SUCCESS)  return(status);
    577          
    578          
    579            		  /* This CORR_THR value should be changed to 0x14 before attempting RX. Testing has shown that
    580          	   * too many false frames are received if the reset value is used. Make it more likely to detect
    581          	   * sync by removing the requirement that both symbols in the SFD must have a correlation value
    582          	   * above the correlation threshold, and make sync word detection less likely by raising the
    583          	   * correlation threshold.
    584          	   */
    585          	  MDMCTRL1 = CORR_THR;
    586          
    587          	  /* tuning adjustments for optimal radio performance; details available in datasheet */
    588          	  RXCTRL = 0x3F;
    589          
    590          	  /* Raises the CCA threshold from about -108dBm to about -80 dBm input level.
    591          	   */
    592          	 CCACTRL0 = CCA_THR;
    593          
    594          	  /* Makes sync word detection less likely by requiring two zero symbols before the sync word.
    595          	   * details available in datasheet.
    596          	   */
    597          	  MDMCTRL0 = 0x85;//控制调制调解器
    598          
    599          	  /* Adjust current in synthesizer; details available in datasheet. */
    600          	  FSCTRL = 0x5A;//调整频率合成器 全部复位
    601          
    602          	  /* Adjust current in VCO; details available in datasheet. */
    603          	  FSCAL1 = 0x00;//调整频率校准
    604          
    605          	  /* Adjust target value for AGC control loop; details available in datasheet. */
    606          	 AGCCTRL1 = 0x15;//AGC参考水平
    607          
    608          	  /* Disable source address matching an autopend for now */
    609          	  SRCMATCH = 0;//源地址匹配和未决位
    610          /*
    611          	  if (radio_flags.bits.pan_coordinator) {
    612          	    FRMFILT0 |= PAN_COORDINATOR;  //accepts frames with only source addressing modes
    613          	  } else {
    614          	    FRMFILT0 &= ~PAN_COORDINATOR;  //rejects frames with only source addressing modes
    615          	  }
    616          */
    617          	  /* Sets TX anti-aliasing filter to appropriate bandwidth.
    618          	   * Reduces spurious emissions close to signal.
    619          	   */
    620          	  TXFILTCFG = TXFILTCFG_RESET_VALUE;
    621          
    622          	  /* disable the CSPT register compare function */
    623          	 // CSPT = 0xFF;
    624          
    625          
    626          
    627          	  /* set RF interrupts one notch above lowest priority (four levels available) */
    628          	 // IP0 |=  IP_RFERR_RF_DMA_BV;
    629          	 // IP1 &= ~IP_RFERR_RF_DMA_BV;
    630          
    631          	//FRMCTRL0_RESET_VALUE: 初始值已经是自动CRC，TX和RX正常模式, 
    632          	// APPEND_DATA_MODE模式为0, AUTO-ACK没有开启
    633          
    634          	if (radio_flags.bits.listen_mode) {
    635              		//corresponds to promiscuous modes
    636              		//radio accepts all packets, the HUSSY!
    637          		FRMFILT0 &= ~FRAME_FILTER_EN;
    638          			
    639          		FRMCTRL0 = FRMCTRL0_RESET_VALUEL &  (~AUTO_ACK);       //no auto ack
    640            	} else {
    641              		// Turning on Address Decoding
    642              		FRMFILT0 |=  FRAME_FILTER_EN;
    643             		 
    644          		FRMCTRL0 = FRMCTRL0_RESET_VALUE | AUTOACK;  //enable auto_ack
    645            	}
    646          	
    647            	local_radio_flags = radio_flags;  //save this for later
    648          
    649            	//pan
    650            	if (radio_flags.bits.pan_coordinator) {
    651             		 FRMFILT0 |= PAN_COORDINATOR;  //accepts frames with only source addressing modes
    652           	} else {
    653              		FRMFILT0 &= ~PAN_COORDINATOR;  //rejects frames with only source addressing modes
    654            	}
    655          
    656          	//#ifdef LOWSN_NO_CHECK_PHYMAC
    657          	//FRMFILT0 &= ~FRAME_FILTER_EN;
    658          	//FRMCTRL0 = FRMCTRL0_RESET_VALUE | AUTOACK;
    659          	//#endif
    660          	
    661          
    662          	// 所有IEEE 802.15.4定义的帧都接收
    663          	FRMFILT1 = 0x78;
    664          	  /* Initialize SRCEXTPENDEN and SRCSHORTPENDEN to zeros */
    665          	MAC_RADIO_SRC_MATCH_INIT_EXTPENDEN();//扩展地址使能或者禁止未决
    666          	MAC_RADIO_SRC_MATCH_INIT_SHORTPENDEN();//源短地址使能或禁止未决
    667          
    668          
    669          	FRMCTRL1 |= SET_RXENMASK_ON_TX;
    670          	//set to max value as the FIFOP flag goes high when complete packet received
    671          	MAC_RADIO_SET_RX_THRESHOLD(128);//缓存阈值不能超过127
    672          
    673          	MAC_RADIO_RX_ON();//RX使能并校准频率合成器
    674          	//RFST = SRXON;
    675          	MAC_RADIO_FLUSH_TX_FIFO();//立即清除TXFIFO缓冲区
    676          	MAC_RADIO_FLUSH_RX_FIFO();//立即清除RXFIFO缓冲区
    677          	MAC_RADIO_TX_ON();//校准之后使能TX
    678          	CSP_START_PROGRAM();//从写到指令寄存器的第一条指令开始执行CSP程序
    679          
    680          	//this controls the frame pending bit in ACK frames.
    681          	//because of auto-ack, we will not have time to determine if data
    682          	//is actually pending or not.
    683          	#if defined(LOWSN_RFD)
    684            		 MAC_RADIO_SACK();  //RFDs never have data pending for FFDs
    685          	#else
    686           		 MAC_RADIO_SACKPEND();  //routers/
    687          	#endif
    688          
    689          	halSetRadioIEEEAddress();//通过软件写入扩展地址
    690          
    691          	/* clear any accidental threshold interrupt that happened as part of power up sequence */
    692          	MAC_RADIO_CLEAR_RX_THRESHOLD_INTERRUPT_FLAG();
    693          
    694          	/* enable threshold interrupts */
    695          	MAC_RADIO_ENABLE_RX_THRESHOLD_INTERRUPT();
    696          
    697          	//MAC_MCU_SFD_ENABLE_INTERRUPT();
    698          
    699          		  /* enable general RF interrupts */
    700          	  IEN2 |= RFIE;
    701          
    702          	  /* enable general RFERR interrupts */
    703          	  IEN0 |= RFERRIE;
    704          
    705          
    706          	return(LOWSN_STATUS_SUCCESS);
    707          
    708          }
    709          
    710          
    711          /*********************************************************************************************
    712          @function:
    713          
    714          regardless of what happens here, we will try TXONCCA after this returns.
    715          **********************************************************************************************/
    716          void  doIEEE_backoff(void)
    717          {
    718            BYTE be, nb, tmp, rannum;
    719            UINT32  delay, start_tick;
    720          
    721            be = aMinBE;
    722            nb = 0;
    723            do {
    724              if (be) {
    725                //do random delay
    726                tmp = be;
    727                //compute new delay
    728                delay = 1;
    729                while (tmp) {
    730                  delay = delay << 1;  //delay = 2**be;
    731                  tmp--;
    732                }
    733                rannum =  halGetRandomByte() & (delay-1); //rannum will be between 0 and delay-1
    734                delay = 0;
    735                while (rannum) {
    736                  delay  += SYMBOLS_TO_MACTICKS(aUnitBackoffPeriod);
    737                  rannum--;
    738                }//delay = aUnitBackoff * rannum
    739                //now do backoff
    740                start_tick = halGetMACTimer();
    741                while (halMACTimerNowDelta(start_tick) < delay);
    742              }
    743              //check CCA
    744              if (MAC_RADIO_CCA_INDICATION())  break;
    745              nb++;
    746              be++;
    747              if (be > aMaxBE) be =aMaxBE;
    748            }while (nb <= macMaxCSMABackoffs);
    749            return;
    750          }
    751          
    752          
    753          
    754          /*********************************************************************************************
    755          @function:
    756          
    757          transmit packet
    758          hdrlen - header lenth
    759          hdr - pointer to header data
    760          plen - payload length
    761          pload - pointer to payload
    762          **********************************************************************************************/
    763          LOWSN_STATUS_ENUM halSendPacket(BYTE flen, BYTE *frm)
    764          {
    765            BYTE len;
    766            LOWSN_STATUS_ENUM res;
    767          
    768            len = flen + PACKET_FOOTER_SIZE;
    769          
    770            DEBUG_STRING(DBG_INFO, "TX PKT Size: ");
    771            DEBUG_UINT8(DBG_INFO,len);
    772            DEBUG_STRING(DBG_INFO,"\n");
    773          
    774              if (len > 127) {
    775              //packet size is too large!
    776              return(LOWSN_STATUS_PHY_TX_PKT_TOO_BIG);
    777            }
    778          
    779              // Turn on receiver if its not on
    780                 MAC_RADIO_FLUSH_RX_FIFO();
    781                 MAC_RADIO_RX_ON();
    782          
    783              // Wait until the transceiver is idle   判断TXACTIVE 或可能的SFD中断
    784              // 发送SFD中断作为条件似乎有问题，但TXACTVIE作为条件没问题.
    785              // 应尽量不在状态机中用while死循环. 将来改进这个
    786              while (FSMSTAT1 & (BV(1) | BV(5) ));
    787          
    788              // Turn off RX frame done interrupt to avoid interference on the SPI interface
    789          
    790              RFIRQF1 = ~IRQ_TXDONE;   // Clear the RF TXDONE flag
    791              INT_SETFLAG_RF(INT_CLR);  //Clear processor interrupt flag
    792              RFIRQM0 &= ~BV(6);    // disable RXPKTDONE interrupt
    793             // IEN2 &= ~BV(0);   // disable general RF interrupts
    794          
    795              MAC_RADIO_FLUSH_TX_FIFO();         // Making sure that the TX FIFO is empty.
    796          
    797              RFD = len;
    798              while (flen) {RFD = *frm; frm++; flen--;}
    799          
    800          
    801               // If the RSSI value is not valid, enable receiver
    802              if(RSSI == 0x80)
    803             {
    804                 MAC_RADIO_RX_ON();
    805                // Turning on Rx and waiting 320u-sec to make the RSSI value become valid.
    806                halWait(1);
    807             }
    808          	
    809              doIEEE_backoff();
    810          
    811              MAC_RADIO_TX_ON_CCA();
    812              //MAC_RADIO_TX_ON() ;
    813          
    814              if(FSMSTAT0 > 30)  //is TX active?
    815              {
    816              // Asserting the status flag and enabling ACK reception if expected.
    817              phyTxStartCallBack();
    818              res = LOWSN_STATUS_SUCCESS;
    819          	
    820              RFIRQM0 |= IRQ_RXPKTDONE; // enable RXPKTDONE interrupt
    821              RFIRQM1 |= IRQ_TXDONE;   //enable IRQ_TXDONE interrupt
    822              //IEN2 |= BV(0);   // enable general RF interrupts
    823              
    824              DEBUG_CHAR( DBG_TX,DBG_CHAR_TXSTART);
    825            }
    826            else
    827            {
    828              MAC_RADIO_FLUSH_TX_FIFO();           //empty buffer
    829              res = LOWSN_STATUS_PHY_CHANNEL_BUSY;
    830              RFIRQM1 &= ~IRQ_TXDONE;   //enable IRQ_TXDONE interrupt
    831              DEBUG_CHAR( DBG_TX,DBG_CHAR_TXBUSY);
    832            }
    833            
    834            return(res);
    835          
    836          }
    837          
    838          
    839          
    840          /*=================================================================================================
    841           * @fn          HAL_ISR_FUNCTION
    842           *
    843           * @brief       UART0 Receive Interrupt
    844           *
    845           * @param       none
    846           *
    847           * @return      none
    848           *		
    849           *=================================================================================================*/
    850          #ifdef  LOWSN_ASYNC_INTIO
    851          
    852          HAL_ISR_FUNCTION( hal_Uart0_RxIsr, URX0_VECTOR)//ts
    853          {
    854            DISABLE_GLOBAL_INTERRUPT();
    855            BYTE x,y;
    856            serio_rxHead++;
    857            if (serio_rxHead == LOWSN_ASYNC_RX_BUFSIZE )
    858            	{
    859            	serio_rxHead = 0;
    860          	}
    861            x = serio_rxHead;  //use tmp variables because of Volatile decl
    862            y = U0DBUF;
    863            serio_rxBuff[x] = y;
    864            ReceiveFlag = 1;
    865            ENABLE_GLOBAL_INTERRUPT();
    866          }
    867          
    868          #endif
    869          
    870          
    871          /*********************************************************************************************
    872          @function:
    873          
    874          **********************************************************************************************/
    875          
    876          #ifdef LOWSN_ENABLE_SLOW_TIMER
    877          
    878          HAL_ISR_FUNCTION( hal_Timer2_Isr, T2_VECTOR)//ts
    879          {
    880          
    881          	UINT8 ActiveInterrupt;
    882          	UINT32 t;
    883             
    884          	ActiveInterrupt = T2IRQF;
    885             	ActiveInterrupt &= T2IRQM;
    886          
    887             	T2IRQF = 0;
    888          
    889            	INT_GLOBAL_ENABLE(INT_OFF);
    890            	INT_SETFLAG_T2(INT_CLR); //clear processor interrupt flag
    891          
    892          
    893            	if (ActiveInterrupt & TIMER2_OVF_COMPARE1F)  {
    894          
    895             		//compute next compare value by reading current timer value, adding offset
    896               		MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    897            		t = 0x0FF & T2MOVF0;
    898            		t += (((UINT16)T2MOVF1)<<8);
    899            		t += (((UINT32)T2MOVF2)<<16);
    900          
    901          		t += T2OVFNUM;  //add offset
    902          		
    903             		MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
    904          		T2MOVF0 = (BYTE) (t);
    905          		T2MOVF1 = (BYTE) (t>>8);
    906          		T2MOVF2 = (BYTE) (t>>16);
    907          
    908          		MAC_RADIO_TIMER_WAKE_UP();
    909          
    910          		evbIntCallback();  //Evaluation board callback
    911          		usrSlowTimerInt();  //user level interrupt callback
    912          	
    913          	}
    914          	
    915          	INT_GLOBAL_ENABLE(INT_ON);
    916          
    917          }
    918          
    919          #endif
    920          
    921          //interrupt for RF error
    922          //this interrupt is same priority as FIFOP interrupt,
    923          //but is polled first, so will occur first.
    924          /**************************************************************************************************
    925           * @fn          macMcuRfErrIsr
    926           *
    927           * @brief       Interrupt service routine that handles all RF Error interrupts.  Only the RX FIFO
    928           *              overflow condition is handled.
    929           *
    930           * @param       none
    931           *
    932           * @return      none
    933           **************************************************************************************************/
    934          
    935          HAL_ISR_FUNCTION( hal_rferr_Isr, RFERR_VECTOR )//ts
    936          {
    937            INT_GLOBAL_ENABLE(INT_OFF);
    938          
    939            // If Rx overflow occurs, the Rx FiFo is reset.
    940            // The Rx DMA is reset and reception is started over.
    941            if(FSMSTAT0 == 17)//RX溢出
    942            {
    943              DEBUG_CHAR( DBG_ITRACE,DBG_CHAR_TXBUSY);
    944              MAC_RADIO_RXTX_OFF();
    945              MAC_RADIO_FLUSH_RX_FIFO();//ISFLUSHRX;
    946              //ISFLUSHRX;
    947              MAC_RADIO_RX_ON();//ISRXON;
    948            }
    949            else if(FSMSTAT0 == 56)//TX下溢
    950            {
    951              DEBUG_CHAR( DBG_ITRACE,DBG_CHAR_RXOFLOW);
    952              MAC_RADIO_FLUSH_TX_FIFO();//ISFLUSHTX;
    953            }
    954          
    955            INT_SETFLAG_RFERR(INT_CLR);
    956          
    957            INT_GLOBAL_ENABLE(INT_ON);
    958          }
    959          
    960          
    961          //This interrupt used for both TX and RX
    962          /*********************************************************************************************
    963          @function:
    964          
    965          **********************************************************************************************/
    966          
    967          HAL_ISR_FUNCTION( hal_rf_Isr, RF_VECTOR )//ts
    968          {
    969          
    970            BYTE flen;
    971            // CC2530对RF中断指示位由CC2430中的一个寄存器扩充到2个寄存器，
    972            BYTE enabledAndActiveInterrupt0, enabledAndActiveInterrupt1;
    973            BYTE *ptr, *rx_frame;
    974            BYTE crc;
    975            BYTE ack_bytes[5];
    976              //define alternate names for readability in this function
    977          #define  fcflsb ack_bytes[0]
    978          #define  fcfmsb  ack_bytes[1]
    979          #define  dstmode ack_bytes[2]
    980          #define  srcmode ack_bytes[3]
    981          
    982            INT_GLOBAL_ENABLE(INT_OFF);
    983            enabledAndActiveInterrupt0 = RFIRQF0;
    984            enabledAndActiveInterrupt1 = RFIRQF1;
    985            RFIRQF0 = 0x00;   // Clear all radio interrupt flags
    986            RFIRQF1 = 0x00;
    987            INT_SETFLAG_RF(INT_CLR);    // Clear MCU interrupt flag
    988          
    989            enabledAndActiveInterrupt0 &= RFIRQM0;
    990            enabledAndActiveInterrupt1 &= RFIRQM1;
    991          
    992          	if(enabledAndActiveInterrupt0 & IRQ_FIFOP)  {
    993                   DEBUG_CHAR( DBG_ITRACE,DBG_CHAR_RXRCV );
    994          	  ptr = NULL; //temporary pointer
    995                   flen = RFD & 0x7f;  //read the length
    996                   if (flen == LOWSN_ACKFRAME_LENGTH)  {
    997           	     	 DEBUG_CHAR( DBG_ITRACE,DBG_CHAR_ACKPKT );
    998           		 ack_bytes[0]= flen;
    999                         ack_bytes[1] =  RFD;  //LSB Frame Control Field
   1000                         ack_bytes[2] = RFD;   //MSB Frame Control Field
   1001                         ack_bytes[3] = RFD;   //dsn
   1002                         ack_bytes[4] = RFD;   //RSSI
   1003                         crc = RFD;	
   1004          	     if (crc & 0x80)  {
   1005          	     	  macRxCallback(ack_bytes, ack_bytes[4]);
   1006          	     }
   1007               	  }
   1008          		 
   1009          	else   {
   1010          	//not an ack packet, lets do some more early rejection
   1011          
   1012          		     	   fcflsb = RFD;
   1013                                  fcfmsb = RFD;
   1014                                  if (!local_radio_flags.bits.listen_mode)  {
   1015                                  	   srcmode = LOWSN_GET_SRC_ADDR(fcfmsb);
   1016                                         dstmode = LOWSN_GET_DST_ADDR(fcfmsb);
   1017          				   if ((srcmode == LOWSN_ADDRMODE_NOADDR) && (dstmode == LOWSN_ADDRMODE_NOADDR))  {
   1018          				         //reject this packet, no addressing info
   1019                                               goto do_rxflush;	
   1020                                  	     }
   1021          		     	     }
   1022                   	
   1023          		           if (!macRxBuffFull())   {
   1024          			        rx_frame = MemAlloc(flen+1);	//开辟空间 放收到的数据
   1025                                       ptr = rx_frame;
   1026          			    }
   1027          		          else  {
   1028          			        //MAC RX buffer is full
   1029                                      DEBUG_CHAR( DBG_ITRACE,DBG_CHAR_MACFULL );
   1030          			    }
   1031          
   1032          		 if (ptr == NULL)  {
   1033          		 	  goto do_rxflush;
   1034          		 }
   1035          		 else   {
   1036          		 	       //save packet, including the length
   1037                                     *ptr = flen; ptr++;
   1038                                      //save the fcflsb, fcfmsb bytes
   1039                                     *ptr = fcflsb; ptr++; flen--;
   1040                                     *ptr = fcfmsb; ptr++; flen--;
   1041                                    //get the rest of the bytes
   1042                                    while (flen) { *ptr = RFD;  flen--; ptr++; }
   1043                                     //do RX callback
   1044                                     //check the CRC
   1045                                     if (*(ptr-1) & 0x80)   {
   1046                                        //CRC good
   1047                                        //change the RSSI byte from 2's complement to unsigned number
   1048                                         *(ptr-2) = *(ptr-2) + 0x80;
   1049          
   1050          			           phyRxCallback();
   1051          		                  macRxCallback(rx_frame, *(ptr-2));
   1052          		 	        }
   1053          			        else  {
   1054          			        	  // CRC bad. Free the packet
   1055                                               MemFree(rx_frame);
   1056          			        }
   1057          		      }
   1058          	 }
   1059          
   1060          		  //flush any remaining bytes
   1061          do_rxflush:
   1062          
   1063          		MAC_RADIO_FLUSH_RX_FIFO();
   1064          		MAC_RADIO_FLUSH_RX_FIFO();
   1065          
   1066          		//don't know why, but the RF flags have to be cleared AFTER a read is done.
   1067          		RFIRQF0 = 0x00;   // Clear all radio interrupt flags
   1068          		RFIRQF1 = 0x00;
   1069          		INT_SETFLAG_RF(INT_CLR);    // Clear MCU interrupt flag
   1070          		
   1071          		MAC_MCU_FIFOP_ENABLE_INTERRUPT();
   1072          
   1073               }
   1074          
   1075            if (enabledAndActiveInterrupt1 & IRQ_TXDONE)  {
   1076               //Finished TX, do call back
   1077              DEBUG_CHAR( DBG_ITRACE,DBG_CHAR_TXFIN );
   1078              phyTxEndCallBack();
   1079              macTxCallback();
   1080              // Clearing the tx done interrupt enable
   1081              MAC_MCU_TXDONE_DISABLE_INTERRUPT();//RFIRQM1 &= ~IRQ_TXDONE;
   1082             }
   1083          
   1084              usrIntCallback();
   1085              INT_GLOBAL_ENABLE(INT_ON);
   1086          
   1087          #undef  fcflsb
   1088          #undef  fcfmsb
   1089          #undef  dstmode
   1090          #undef  srcmode
   1091          }
   1092          
   1093          
   1094          /*********************************************************************************************
   1095          @function:
   1096          
   1097          software delay, waits is in milliseconds
   1098          **********************************************************************************************/
   1099          void halWait(BYTE wait){
   1100            UINT32 largeWait;
   1101          
   1102            if(wait == 0)
   1103            {return;}
   1104            largeWait = ((UINT16) (wait << 7));
   1105            largeWait += 114*wait;
   1106          
   1107          
   1108            largeWait = (largeWait >> CLKSPD);
   1109            while(largeWait--);
   1110          
   1111            return;
   1112          }
   1113          
   1114          
   1115          /*********************************************************************************************
   1116          @function:
   1117          
   1118          **********************************************************************************************/
   1119          void halWaitMs(const UINT32 msecs){
   1120            UINT32 towait;
   1121          
   1122            towait = msecs;
   1123            while (towait > 100)
   1124            {
   1125              halWait(100);
   1126              towait -= 100;
   1127            }
   1128            halWait(towait);
   1129          }
   1130          
   1131          /*********************************************************************************************
   1132          @function:
   1133          
   1134          **********************************************************************************************/
   1135          
   1136          
   1137          
   1138          
   1139          
   1140          
   1141          /* for revision E, this sw workaround require additional code in all
   1142          * ISR's that are used to wake up from PM.
   1143          */
   1144          #define HAL_SLEEP_SET_POWER_MODE(mode)  do{ SLEEPCMD &= ~0x03;  /* clear mode bits */               \
   1145            SLEEPCMD |= mode;   /* set mode bits   */               \
   1146              asm("NOP");                                          \
   1147                asm("NOP");                                          \
   1148                  asm("NOP");                                          \
   1149                    if( SLEEPCMD & 0x03 )                                   \
   1150                      {                                                    \
   1151                        PCON |= 0x01;  /* enable mode */                   \
   1152                          asm("NOP");    /* first instruction after sleep*/  \
   1153                                                           }; } while(0)
   1154          
   1155          
   1156          
   1157          /*********************************************************************************************
   1158          @function:
   1159          输入参数:  SleepMode
   1160          #define POWER_MODE_0  0x00  // Clock oscillators on, voltage regulator on
   1161          #define POWER_MODE_1  0x01  // 32.768 KHz oscillator on, voltage regulator on
   1162          #define POWER_MODE_2  0x02  // 32.768 KHz oscillator on, voltage regulator off
   1163          #define POWER_MODE_3  0x03  // All clock oscillators off, voltage regulator off
   1164          
   1165          
   1166          **********************************************************************************************/
   1167          __near_func  void halSleep(UINT8 SleepMode, UINT32 msecs )
   1168          {
   1169            UINT32 t;
   1170            UINT32 delta;
   1171            BOOL gie_status;
   1172          
   1173            SAVE_AND_DISABLE_GLOBAL_INTERRUPT(gie_status);
   1174            //read the sleep timer
   1175            delta = (32768 * msecs)/1000;
   1176            t = 0xFF & ST0;
   1177            t += (((UINT16)ST1)<<8);
   1178            t += (((UINT32) ST2 & 0xFF)<<16);
   1179          
   1180            //compute the compare value  and subtract the processing time spent in function halSleep()
   1181            t = (t + delta - HAL_SLEEP_ADJ_TICKS)&0x00FFFFFF;
   1182          
   1183            //write the new sleep timer value
   1184            ST2 = (t >> 16)&0xFF;
   1185            ST1 = (t >> 8)&0xFF;
   1186            ST0 = t & 0xFF;
   1187            //clear the sleep flag, enable the interrupt
   1188            IRCON = IRCON & 0x7F; //clear the sleep flag IRCON.STIF = 0;
   1189            IEN0 = IEN0 | (1<<5); //enable the interrupt  IEN0.STIE = 1;
   1190          
   1191            ENABLE_GLOBAL_INTERRUPT();  //interrupts must be enabled to wakeup!
   1192            //configure the power mode and sleep
   1193            //SET_POWER_MODE(POWER_MODE_2);
   1194            //SET_POWER_MODE(POWER_MODE_1);
   1195          
   1196            // set CC2430 power mode
   1197            HAL_SLEEP_SET_POWER_MODE(SleepMode);
   1198          
   1199          
   1200            //wake up!
   1201            //disable sleep interrupt
   1202            DISABLE_GLOBAL_INTERRUPT();
   1203            IEN0 = IEN0 & ~(1<<5);  // IEN0.STIE = 0;
   1204          
   1205            //wait for everything to power back up
   1206            while (!(SLEEPSTA & XOSC_STB));         \
   1207              asm("NOP");
   1208              RESTORE_GLOBAL_INTERRUPT(gie_status);
   1209          };
   1210          
   1211          
   1212          
   1213          /*********************************************************************************************
   1214          @function:
   1215          
   1216          **********************************************************************************************/
   1217          INT16 halGetAdcValue(){
   1218            INT16 value;
   1219            value = ((INT16)ADCH) << 8;
   1220            value |= (INT16)ADCL;
   1221            return value;
   1222          }
   1223          
   1224          
   1225          // 获取电池电压
   1226          
   1227          UINT16 getVoltageValue(void)
   1228          {
   1229          
   1230            UINT16 value;
   1231          
   1232            ADCIF = 0;
   1233          
   1234            ADCCON3 = (HAL_ADC_REF_125V | HAL_ADC_DEC_128 | HAL_ADC_CHN_VDD3);
   1235          
   1236            while ( !ADCIF );
   1237          
   1238            value = ADCL;
   1239            value |= ((UINT16) ADCH) << 8;
   1240          
   1241            
   1242            value = value >> 6;   
   1243            value = (UINT16)(value * 37.5);
   1244            value = value >> 9;  
   1245          
   1246            // 经处理后，返回的值为VDD实际电压值乘以10
   1247          
   1248            return value;
   1249          
   1250          }
   1251          
   1252          
   1253          
   1254          
   1255          /*********************************************************************************************
   1256          @function:
   1257          
   1258          **********************************************************************************************/
   1259          HAL_ISR_FUNCTION( hal_St_Isr, ST_VECTOR)//ts
   1260          {
   1261            DRV_SLEEP_TIMER_CLEAR_INT( );//睡眠定时器无中断未决
   1262            DRV_CLEAR_SLEEP_MODE();//供电模式为0模式
   1263          }
   1264          
   1265          
   1266          /*********************************************************************************************
   1267          @function:
   1268          
   1269          //functions used by EVboard.
   1270          
   1271          //-----------------------------------------------------------------------------
   1272          // See hal.h for a description of this function.
   1273          //-----------------------------------------------------------------------------
   1274          **********************************************************************************************/
   1275          INT16 halAdcSampleSingle(BYTE reference, BYTE resolution, UINT8 input) //不需要改动ADCCFG数据手册上没有但是TI上有
   1276          {
   1277            BYTE volatile temp;
   1278            INT16 value;
   1279          
   1280            //reading out any old conversion value
   1281            temp = ADCH;
   1282            temp = ADCL;
   1283          
   1284          
   1285            ADC_ENABLE_CHANNEL(input);
   1286            ADC_STOP();
   1287          
   1288            ADC_SINGLE_CONVERSION(reference | resolution | input);
   1289          
   1290            while (!ADC_SAMPLE_READY());
   1291          
   1292            ADC_DISABLE_CHANNEL(input);
   1293          
   1294            value = (((INT16)ADCH) << 8);
   1295            value |= ADCL;
   1296          
   1297            resolution >>= 3;
   1298            return value >> (8 - resolution);
   1299          }
   1300          
   1301          
   1302          /***********************************************************************************
   1303          * @fn      halRfTransmit
   1304          *
   1305          * @brief   Transmit frame with Clear Channel Assessment.
   1306          *
   1307          * @param   none
   1308          *
   1309          * @return  uint8 - SUCCESS or FAILED
   1310          */
   1311          UINT8 halRfTransmit(void)
   1312          {
   1313              UINT8 status;
   1314          
   1315              MAC_RADIO_TX_ON() ;
   1316          
   1317              // Waiting for transmission to finish
   1318              ///while(!(RFIRQF1 & IRQ_TXDONE) );
   1319          
   1320              RFIRQF1 = ~IRQ_TXDONE;
   1321              status= 0;
   1322          
   1323              return status;
   1324          }
   1325          
   1326          BOOL HalUartBufferEmpty(void)
   1327          {
   1328           	 return (serio_rxHead == serio_rxTail);
   1329          }
   1330          
   1331          
   1332          
   1333          void halShutdown(void) {
   1334          
   1335          // 等待添加
   1336          
   1337          }
   1338          
   1339          void halWarmstart(void) {
   1340          
   1341          // 等待添加
   1342            
   1343           }
   1344          
   1345          
   1346          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     HalUartBufferEmpty                 2      0      0
     doIEEE_backoff                     1      0     30
       -> halGetRandomByte              2      0     40
       -> halGetMACTimer                0      0     40
       -> halGetMACTimer                0      0     40
     getVoltageValue                    0      0     16
     halAdcSampleSingle                 1      0     13
     halGetAdcValue                     2      0      0
     halGetMACTimer                     0      0     36
     halGetProcessorIEEEAddress         3      0      0
     halGetProcessorIEEEAddress_MAC     3      0      8
     halGetRandomByte                   0      0     20
     halGetch                           2      0      0
     halGetchRdy                        2      0      0
     halInit                            2      0      0
       -> halInitUart                   4      0      0
       -> halInitMACTimer               4      0      0
     halInitMACTimer                    0      0      0
     halInitRadio                       2      0      2
       -> halSetRadioIEEEFrequency      4      0      0
       -> halSetRadioIEEEAddress        4      0      0
     halInitUart                        2      0      0
     halMacTicksToUs                    0      0     16
     halOverflowSetCount                0      0     16
     halPutch                           0      0     10
     halRawPut                          0      0      0
     halRfTransmit                      0      0      0
     halSendPacket                      0      0     10
       -> conPrintROMString_func        0      0     20
       -> conPrintUINT8                 0      0     20
       -> conPrintROMString_func        0      0     20
       -> halWait                       0      0     20
       -> doIEEE_backoff                0      0     20
       -> phyTxStartCallBack            0      0     20
       -> halPutch                      0      0     20
       -> halPutch                      0      0     20
     halSetChannel                      2      0      0
       -> halSetRadioIEEEFrequency      4      0      0
     halSetRadioIEEEAddress             2      0      8
       -> halGetProcessorIEEEAddress_MAC
                                        4      0     16
     halSetRadioIEEEFrequency           2      0      0
     halSetRadioPANID                   2      0      0
     halSetRadioShortAddr               2      0      0
     halShutdown                        0      0      0
     halSleep                           1      0     20
     halUtilMemCopy                     1      0      9
     halWait                            0      0     32
     halWaitMs                          0      0     16
       -> halWait                       0      0     32
       -> halWait                       0      0     32
     halWarmstart                       0      0      0
     hal_St_Isr                         2      0      0
     hal_Timer2_Isr                     0      0     22
       -> evbIntCallback                0      0     44
       -> usrSlowTimerInt               0      0     44
     hal_Uart0_RxIsr                    8      0      0
     hal_rf_Isr                        21      0      5
       -> halPutch                     40      0     10
       -> halPutch                     40      0     10
       -> macRxCallback                40      0     10
       -> macRxBuffFull                40      0     10
       -> MemAlloc                     40      0     10
       -> halPutch                     40      0     10
       -> phyRxCallback                40      0     10
       -> macRxCallback                40      0     10
       -> MemFree                      40      0     10
       -> halPutch                     40      0     10
       -> phyTxEndCallBack             40      0     10
       -> macTxCallback                40      0     10
       -> usrIntCallback               40      0     10
     hal_rferr_Isr                     15      0      0
       -> halPutch                     30      0      0
       -> halPutch                     30      0      0
     macMcuOverflowCapture              1      0     16


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     U0CSR                                     1
     PCON                                      1
     _A_TCON                                   1
     RFIRQF1                                   1
     T2CTRL                                    1
     ST0                                       1
     ST1                                       1
     ST2                                       1
     IEN2                                      1
     S1CON                                     1
     SLEEPSTA                                  1
     CLKCONSTA                                 1
     T2IRQF                                    1
     T2M0                                      1
     T2M1                                      1
     T2MOVF0                                   1
     T2MOVF1                                   1
     T2MOVF2                                   1
     T2IRQM                                    1
     _A_IEN0                                   1
     ADCCON1                                   1
     ADCCON3                                   1
     _A_IEN1                                   1
     ADCL                                      1
     ADCH                                      1
     SLEEPCMD                                  1
     _A_IRCON                                  1
     U0DBUF                                    1
     U0BAUD                                    1
     T2MSEL                                    1
     U0UCR                                     1
     U0GCR                                     1
     CLKCONCMD                                 1
     RFD                                       1
     RFST                                      1
     _A_IRCON2                                 1
     RFIRQF0                                   1
     PERCFG                                    1
     ADCCFG                                    1
     P0SEL                                     1
     P1SEL                                     1
     local_radio_flags                         2
     long_address                              8
     serio_rxBuff                            150
     serio_rxHead                              1
     serio_rxTail                              1
     ReceiveFlag                               1
     halInit                                 109
     halInitUart                              30
     halPutch                                 11
     halRawPut                                11
     halGetch                                 61
     halGetchRdy                              29
     halUtilMemCopy                           44
     halInitMACTimer                          54
     halGetMACTimer                           90
     macMcuOverflowCapture                   100
     halOverflowSetCount                      60
     halMacTicksToUs                          56
     halGetRandomByte                          5
     halSetRadioIEEEFrequency                 91
     halSetChannel                            18
     halGetProcessorIEEEAddress               93
     halGetProcessorIEEEAddress_MAC           93
     halSetRadioIEEEAddress                  115
     halSetRadioPANID                         21
     halSetRadioShortAddr                     21
     halInitRadio                            269
     doIEEE_backoff                          175
     halSendPacket                           238
     xxxxromstr                               14
     xxxxromstr                                2
     hal_Uart0_RxIsr                          90
     hal_Timer2_Isr                          146
     hal_rferr_Isr                            79
     hal_rf_Isr                              572
     halWait                                 128
     halWaitMs                                67
     halSleep                                248
     halGetAdcValue                           28
     getVoltageValue                         110
     hal_St_Isr                               12
     halAdcSampleSingle                      135
     halRfTransmit                            11
     HalUartBufferEmpty                       29
     halShutdown                               3
     halWarmstart                              3
     ??hal_rferr_Isr??INTVEC 3                 3
     ??hal_Uart0_RxIsr??INTVEC 19              3
     ??hal_St_Isr??INTVEC 43                   3
     ??hal_Timer2_Isr??INTVEC 83               3
     ??hal_rf_Isr??INTVEC 131                  3
     __Constant_1                              4
     ?<Initializer for __Constant_1>           4
     __Constant_10                             4
     ?<Initializer for __Constant_10>          4
     __Constant_0                              4
     ?<Initializer for __Constant_0>           4
     __Constant_14                             4
     ?<Initializer for __Constant_14>          4
     __Constant_ffffff                         4
     ?<Initializer for __Constant_ffffff>      4
     __Constant_f424                           4
     ?<Initializer for __Constant_f424>        4
     __Constant_ffffffff                       4
     ?<Initializer for __Constant_ffffffff>    4
     __Constant_ffffff9c                       4
     ?<Initializer for __Constant_ffffff9c>    4
     __Constant_65                             4
     ?<Initializer for __Constant_65>          4
     __Constant_8000                           4
     ?<Initializer for __Constant_8000>        4
     __Constant_3e8                            4
     ?<Initializer for __Constant_3e8>         4
     __Constant_ffffffe2                       4
     ?<Initializer for __Constant_ffffffe2>    4
     __Constant_42160000                       4
     ?<Initializer for __Constant_42160000>    4
     ??halInit?relay                           6
     ??halInitUart?relay                       6
     ??halPutch?relay                          6
     ??halRawPut?relay                         6
     ??halGetch?relay                          6
     ??halGetchRdy?relay                       6
     ??halUtilMemCopy?relay                    6
     ??halInitMACTimer?relay                   6
     ??halGetMACTimer?relay                    6
     ??macMcuOverflowCapture?relay             6
     ??halOverflowSetCount?relay               6
     ??halMacTicksToUs?relay                   6
     ??halGetRandomByte?relay                  6
     ??halSetRadioIEEEFrequency?relay          6
     ??halSetChannel?relay                     6
     ??halSetRadioIEEEAddress?relay            6
     ??halSetRadioPANID?relay                  6
     ??halSetRadioShortAddr?relay              6
     ??halInitRadio?relay                      6
     ??doIEEE_backoff?relay                    6
     ??halSendPacket?relay                     6
     ??halWait?relay                           6
     ??halWaitMs?relay                         6
     ??halGetAdcValue?relay                    6
     ??getVoltageValue?relay                   6
     ??halAdcSampleSingle?relay                6
     ??halRfTransmit?relay                     6
     ??HalUartBufferEmpty?relay                6
     ??halShutdown?relay                       6
     ??halWarmstart?relay                      6

 
 2 122 bytes in segment BANKED_CODE
   180 bytes in segment BANK_RELAYS
    16 bytes in segment CODE_C
    15 bytes in segment INTVEC
 1 333 bytes in segment NEAR_CODE
    41 bytes in segment SFR_AN
    52 bytes in segment XDATA_I
    52 bytes in segment XDATA_ID
   163 bytes in segment XDATA_Z
 
 3 651 bytes of CODE  memory (+ 67 bytes shared)
     0 bytes of DATA  memory (+ 41 bytes shared)
   163 bytes of XDATA memory (+ 52 bytes shared)

Errors: none
Warnings: none
